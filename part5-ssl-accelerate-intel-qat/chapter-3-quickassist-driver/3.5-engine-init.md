# 3.5 Engine Init

## 3.5.1 qat\_engine\_init\(\)

bind\_qat\(\)函数中通过ENGINE\_set\_init\_function\(e, qat\_engine\_init\);设置qat\_engine\_init\(\)为ENGINE\_init\(\)的调用函数:

```c
469 int qat_engine_init(ENGINE *e)
 470 {
 471     qat_pthread_mutex_lock();
 472     if (engine_inited) { 
 473         qat_pthread_mutex_unlock();
 474         return 1;
 475     }  
 476 
 477     DEBUG("QAT Engine initialization:\n");
 478     CRYPTO_INIT_QAT_LOG();
 479 
 480 #ifdef QAT_HW
 481     if (qat_offload) {
 482         if (!qat_init(e)) {
 483             WARN("QAT initialization Failed\n");
 484             return 0;
 485         }
 486     }
 487 #endif
 488 
 489 #ifdef QAT_SW
 490     if (!qat_offload) {
 491         if (!multibuff_init(e)) {
 492             WARN("Multibuff initialization Failed\n");
 493             return 0;
 494         }
 495     }
 496 #endif
 497    
 498     engine_inited = 1;
 499     qat_pthread_mutex_unlock();
 500    
 501     return 1;
 502 }  

```

## 3.5.2 qat\_init

```c
352 int qat_init(ENGINE *e)
353 {
354     int instNum, err;
355     CpaStatus status = CPA_STATUS_SUCCESS;
356     int ret_pthread_sigmask;
357     Cpa32U package_id = 0;
...
379     /* Initialise the QAT hardware */
380     if (CPA_STATUS_SUCCESS !=
381         icp_sal_userStart(ICPConfigSectionName_libcrypto)) {
382         WARN("icp_sal_userStart failed\n");
383         QATerr(QAT_F_QAT_INIT, QAT_R_ICP_SAL_USERSTART_FAIL);
384         pthread_key_delete(thread_local_variables);
385         qat_pthread_mutex_unlock();
386         return 0;
387     }
388 
389     /* Get the number of available instances */
390     status = cpaCyGetNumInstances(&qat_num_instances);
391     if (CPA_STATUS_SUCCESS != status) {
392         WARN("cpaCyGetNumInstances failed, status=%d\n", status);
393         QATerr(QAT_F_QAT_INIT, QAT_R_GET_NUM_INSTANCE_FAILURE);
394         qat_pthread_mutex_unlock();
395         qat_engine_finish(e);
396         return 0;
397     }
398     if (!qat_num_instances) {
399         WARN("No crypto instances found\n");
400         QATerr(QAT_F_QAT_INIT, QAT_R_INSTANCE_UNAVAILABLE);
401         qat_pthread_mutex_unlock();
402         qat_engine_finish(e);
403         return 0;
404     }
405 
406     DEBUG("Found %d Cy instances\n", qat_num_instances);
407 
408     /* Allocate memory for the instance handle array */
409     qat_instance_handles =
410         (CpaInstanceHandle *) OPENSSL_zalloc(((int)qat_num_instances) *
411                                              sizeof(CpaInstanceHandle));
412     if (NULL == qat_instance_handles) {
413         WARN("OPENSSL_zalloc() failed for instance handles.\n");
414         QATerr(QAT_F_QAT_INIT, QAT_R_INSTANCE_HANDLE_MALLOC_FAILURE);
415         qat_pthread_mutex_unlock();
416         qat_engine_finish(e);
417         return 0;
418     }
419 
420     /* Get the Cy instances */
421     status = cpaCyGetInstances(qat_num_instances, qat_instance_handles);
422     if (CPA_STATUS_SUCCESS != status) {
423         WARN("cpaCyGetInstances failed, status=%d\n", status);
424         QATerr(QAT_F_QAT_INIT, QAT_R_GET_INSTANCE_FAILURE);
425         qat_pthread_mutex_unlock();
426         qat_engine_finish(e);
427         return 0;
428     }
429 
430     if (!enable_external_polling && !enable_inline_polling) {
431 #ifndef __FreeBSD__
432         if (qat_is_event_driven()) {
433             CpaStatus status;
434             int flags;
435             int engine_fd;
436 
437             /*   Add the file descriptor to an epoll event list */
438             internal_efd = epoll_create1(0);
439             if (-1 == internal_efd) {
440                 WARN("Error creating epoll fd\n");
441                 QATerr(QAT_F_QAT_INIT, QAT_R_EPOLL_CREATE_FAILURE);
442                 qat_pthread_mutex_unlock();
443                 qat_engine_finish(e);
444                 return 0;
445             }
446 
447             for (instNum = 0; instNum < qat_num_instances; instNum++) {
448                 /*   Get the file descriptor for the instance */
449                 status =
450                     icp_sal_CyGetFileDescriptor(qat_instance_handles[instNum],
451                                                 &engine_fd);
452                 if (CPA_STATUS_FAIL == status) {
453                     WARN("Error getting file descriptor for instance\n");
454                     QATerr(QAT_F_QAT_INIT, QAT_R_GET_FILE_DESCRIPTOR_FAILURE);
455                     qat_pthread_mutex_unlock();
456                     qat_engine_finish(e);
457                     return 0;
458                 }
459                 /*   Make the file descriptor non-blocking */
460                 eng_poll_st[instNum].eng_fd = engine_fd;
461                 eng_poll_st[instNum].inst_index = instNum;
462 
463                 flags = qat_fcntl(engine_fd, F_GETFL, 0);
464                 if (qat_fcntl(engine_fd, F_SETFL, flags | O_NONBLOCK) == -1) {
465                     WARN("Failed to set engine_fd as NON BLOCKING\n");
466                     QATerr(QAT_F_QAT_INIT,
467                            QAT_R_SET_FILE_DESCRIPTOR_NONBLOCKING_FAILURE);
468                     qat_pthread_mutex_unlock();
469                     qat_engine_finish(e);
470                     return 0;
471                 }
472 
473                 eng_epoll_events[instNum].data.ptr = &eng_poll_st[instNum];
474                 eng_epoll_events[instNum].events = EPOLLIN | EPOLLET;
475                 if (-1 ==
476                     epoll_ctl(internal_efd, EPOLL_CTL_ADD, engine_fd,
477                               &eng_epoll_events[instNum])) {
478                     WARN("Error adding fd to epoll\n");
479                     QATerr(QAT_F_QAT_INIT, QAT_R_EPOLL_CTL_FAILURE);
480                     qat_pthread_mutex_unlock();
481                     qat_engine_finish(e);
482                     return 0;
483                 }
484             }
485         }
486 #endif
487     }
488 
489     /* Set translation function and start each instance */
490     for (instNum = 0; instNum < qat_num_instances; instNum++) {
491         /* Retrieve CpaInstanceInfo2 structure for that instance */
492         status = cpaCyInstanceGetInfo2(qat_instance_handles[instNum],
493                                        &qat_instance_details[instNum].qat_instance_info);
494         if (CPA_STATUS_SUCCESS != status ) {
495             WARN("cpaCyInstanceGetInfo2 failed. status = %d\n", status);
496             QATerr(QAT_F_QAT_INIT, QAT_R_GET_INSTANCE_INFO_FAILURE);
497             qat_pthread_mutex_unlock();
498             qat_engine_finish(e);
499             return 0;
500         }
501 
502         package_id = qat_instance_details[instNum].qat_instance_info.physInstId.packageId;
503         qat_accel_details[package_id].qat_accel_present = 1;
504         if (package_id >= qat_num_devices) {
505             qat_num_devices = package_id + 1;
506         }
507 
508         /* Set the address translation function */
509         status = cpaCySetAddressTranslation(qat_instance_handles[instNum],
510                                             virtualToPhysical);
511         if (CPA_STATUS_SUCCESS != status) {
512             WARN("cpaCySetAddressTranslation failed, status=%d\n", status);
513             QATerr(QAT_F_QAT_INIT, QAT_R_SET_ADDRESS_TRANSLATION_FAILURE);
514             qat_pthread_mutex_unlock();
515             qat_engine_finish(e);
516             return 0;
517         }
518 
519         /* Start the instances */
520         status = cpaCyStartInstance(qat_instance_handles[instNum]);
521         if (CPA_STATUS_SUCCESS != status) {
522             WARN("cpaCyStartInstance failed, status=%d\n", status);
523             QATerr(QAT_F_QAT_INIT, QAT_R_START_INSTANCE_FAILURE);
524             qat_pthread_mutex_unlock();
525             qat_engine_finish(e);
526             return 0;
527         }
528 
529         qat_instance_details[instNum].qat_instance_started = 1;
530         DEBUG("Started Instance No: %d Located on Device: %d\n", instNum, package_id);
531 
532 #if !defined(__FreeBSD__) && !defined(QAT_DRIVER_INTREE)
533         if (enable_sw_fallback) {
534             DEBUG("cpaCyInstanceSetNotificationCb instNum = %d\n", instNum);
535             status = cpaCyInstanceSetNotificationCb(qat_instance_handles[instNum],
536                                                     qat_instance_notification_callbackFn,
537                                                     (void *)(intptr_t)instNum);
538             if (CPA_STATUS_SUCCESS != status) {
539                 WARN("cpaCyInstanceSetNotificationCb failed, status=%d\n", status);
540                 QATerr(QAT_F_QAT_INIT, QAT_R_SET_NOTIFICATION_CALLBACK_FAILURE);
541                 qat_pthread_mutex_unlock();
542                 qat_engine_finish(e);
543                 return 0;
544             }
545         }
546 #endif
547     }
548 
549     if (!enable_external_polling && !enable_inline_polling) {
550         if (!qat_is_event_driven()) {
551             sigemptyset(&set);
552             sigaddset(&set, SIGUSR1);
553             ret_pthread_sigmask = pthread_sigmask(SIG_BLOCK, &set, NULL);
554             if (ret_pthread_sigmask != 0) {
555                 WARN("pthread_sigmask error\n");
556                 QATerr(QAT_F_QAT_INIT, QAT_R_POLLING_THREAD_SIGMASK_FAILURE);
557                 qat_pthread_mutex_unlock();
558                 qat_engine_finish(e);
559                 return 0;
560             }
561         }
562 #ifndef __FreeBSD__
563         if (qat_create_thread(&qat_polling_thread, NULL, qat_is_event_driven() ?
564                               event_poll_func : qat_timer_poll_func, NULL)) {
565 #else
566         if (qat_create_thread(&qat_polling_thread, NULL, qat_timer_poll_func, NULL)) {
567 #endif
568             WARN("Creation of polling thread failed\n");
569             QATerr(QAT_F_QAT_INIT, QAT_R_POLLING_THREAD_CREATE_FAILURE);
570             qat_polling_thread = pthread_self();
571             qat_pthread_mutex_unlock();
572             qat_engine_finish(e);
573             return 0;
574         }
575         if (qat_adjust_thread_affinity(qat_polling_thread) == 0) {
576             WARN("Setting polling thread affinity failed\n");
577             QATerr(QAT_F_QAT_INIT, QAT_R_SET_POLLING_THREAD_AFFINITY_FAILURE);
578             qat_pthread_mutex_unlock();
579             qat_engine_finish(e);
580             return 0;
581         }
582         if (!qat_is_event_driven()) {
583             while (!cleared_to_start)
584                 sleep(1);
585         }
586     }
587     return 1;
588 }
```

381: 初始化QAT hardware;

390: 调用cpaCyGetNumInstances\(\)获得instance的数量;

409: 为每个instance分配一个handle;

421: 调用cpaCyGetNumInstances\(\)填充instance数组;

## 3.5.3 icp\_sal\_userStart

```c
169 CpaStatus icp_sal_userStart(const char *process_name)                                                                                                                                                                                     
170 {
171     char name[ADF_CFG_MAX_SECTION_LEN_IN_BYTES + 1] = {0};
172     CpaStatus status = CPA_STATUS_SUCCESS;
173     pid_t pid = getpid(); 
...
192     if (0 == start_ref_count)
193     {
194         status = icp_adf_userProcessToStart(process_name, name);                                                                                                                                                                          
195 
196         if (CPA_STATUS_SUCCESS != status)                                                                                                                                                                                                 
197         {
198             LAC_LOG_DEBUG("icp_adf_userProcessToStart failed\n");
199             osalMutexUnlock(&sync_lock);   
200             osalMutexDestroy(&sync_lock);  
201             return CPA_STATUS_FAIL;    
202         }
203         status = do_userStart(name);                                                                                                                                                                                                      
204     }
...
```



```c
145 static CpaStatus do_userStart(const char *process_name)
146 {
147     CpaStatus status = CPA_STATUS_SUCCESS;
148     status = icpSetProcessName(process_name);
149     LAC_CHECK_STATUS(status);
150     status = SalCtrl_AdfServicesRegister();
151     LAC_CHECK_STATUS(status);
152 
153     status = icp_adf_userProxyInit(process_name);
154     if (CPA_STATUS_SUCCESS != status)
155     {
156         LAC_LOG_ERROR("Failed to initialize proxy\n");
157         SalCtrl_AdfServicesUnregister();
158         return status;
159     }
160     status = SalCtrl_AdfServicesStartedCheck();
161     if (CPA_STATUS_SUCCESS != status)
162     {
163         LAC_LOG_ERROR("Failed to start services\n");
164         SalCtrl_AdfServicesUnregister();
165     }
166     return status;
167 }
```



```c
319 CpaStatus icp_adf_userProxyInit(char const *const name)
320 {
321     CpaStatus status = CPA_STATUS_FAIL;
322     
323     ICP_CHECK_FOR_NULL_PARAM(name);
324     /* Allow the user to call init just once */
325     if (init_ctr)
326     {
327         ADF_ERROR("User proxy alreay initialized\n");
328         return status;
329     }
330     init_ctr = 1;
331     /* Connect to kernel space. */
332     status = adf_process_proxy_init();
333     if (CPA_STATUS_SUCCESS != status)
334     {
335         ADF_ERROR("adf_process_proxy_init failed\n");
336         return status;
337     }
338     if (!processes_lock)
339     {
340         if (OSAL_SUCCESS != ICP_MUTEX_INIT(&processes_lock))
341         {
342             ADF_ERROR("Mutex init failed for processes_lock\n");
343             status = CPA_STATUS_RESOURCE;
344         }
345     }
346     return status;
347 }
```



```c
275 /*
276  * adf_process_proxy_init
277  * Init process proxy and connect to kernel space.
278  * For every acceleration device in the system open
279  * events and rings interface and start event listening threads
280  */
281 STATIC CpaStatus adf_process_proxy_init(void)
282 {
283     if (adf_process_proxy_running())
284     {
285         ADF_ERROR("Proxy already running\n");
286         return CPA_STATUS_FAIL;
287     }
288 
289     if (adf_event_monitor_create() != CPA_STATUS_SUCCESS)
290         return CPA_STATUS_FAIL;
291 
292     adf_process_proxy_start();
293     if (adf_init_devices())
294     {
295         ADF_ERROR("Error initializing devices\n");
296         return CPA_STATUS_FAIL;
297     }
298 
299     return adf_proxy_get_devices();
300 }
```



```c
492 CpaStatus adf_proxy_get_devices(void)
493 {   
494     int32_t ctr = 0;
495     Cpa32U num_dev = 0;
496 
497     if (icp_adf_get_numDevices(&num_dev))
498         return CPA_STATUS_FAIL;
499     for (ctr = 0; ctr < num_dev; ctr++)
500     {
501         if (adf_proxy_get_device(ctr))
502         {
503             ADF_ERROR("adf_proxy_get_device error ctr\n");
504             return CPA_STATUS_FAIL;
505         }
506     }
507     return CPA_STATUS_SUCCESS;
508 }   
```



```c
437 STATIC int32_t adf_proxy_get_device(int dev_id)
438 {
439     int32_t err;
440     int ring_file_hnd = 0;
441 
442     if ((dev_id >= ADF_MAX_DEVICES) || (NULL != accel_tbl[dev_id]))
443         return 0; /* Invalid dev_id or Already created. */
444 
445     if (!uio_acces_dev_exist(dev_id, NULL))
446         return 0;
447 
448     if (uio_create_accel_dev(&accel_tbl[dev_id], dev_id))
449     {
450         err = ENOMEM;
451         goto adf_proxy_get_device_exit;
452     }
453 
454     err = adf_user_transport_init(accel_tbl[dev_id]);
455     if (0 != err)
456     {
457         goto adf_proxy_get_device_init_failed;
458     }
459     adf_proxy_get_dev_events(dev_id);
460     num_of_instances++;
461 
462     /* Open ring_file_hnd for admin messages */
463     ring_file_hnd = open(ADF_CTL_DEVICE_NAME, O_RDONLY);
464     if (-1 != ring_file_hnd)
465         accel_tbl[dev_id]->ringFileHdl = ring_file_hnd;
466 
467     return 0;
468 
469 adf_proxy_get_device_init_failed:
470     free(accel_tbl[dev_id]);
471     accel_tbl[dev_id] = NULL;
472 adf_proxy_get_device_exit:
473     return err;
474 }
```

460: 增加num\_of\_instances来记录device的数量\(用num\_of\_instances这个名字好像不太合适\);

```c
909 CpaStatus adf_user_transport_init(icp_accel_dev_t *accel_dev)
910 {
911     CpaStatus status = CPA_STATUS_SUCCESS;
912     Cpa32U i = 0;
913     Cpa32S x = 0;
914     adf_dev_bank_handle_t *bank = NULL;
915     adf_dev_bank_handle_t *banks = NULL;
916     ICP_CHECK_FOR_NULL_PARAM(accel_dev);
917 
918     status = adf_proxy_populate_device_info(accel_dev);
919     if (CPA_STATUS_SUCCESS != status)
920     {
921         return status;
922     }
923     
924     banks = accel_dev->banks;
925     for (i = 0; i < accel_dev->maxNumBanks; i++)
926     {   
927         bank = &banks[i];
928         bank->user_bank_lock = ICP_MALLOC_GEN(sizeof(ICP_MUTEX));
929         if (!bank->user_bank_lock)
930         {
931             ADF_ERROR("Could not alloc memory for bank mutex\n");
932             for (x = i - 1; x >= 0; x--)
933             {
934                 bank = &banks[x];
935                 ICP_MUTEX_UNINIT(bank->user_bank_lock);
936                 ICP_FREE(bank->user_bank_lock);
937             }
938             adf_proxy_depopulate_device_info(accel_dev);
939             return CPA_STATUS_FAIL;
940         }
941         ICP_MUTEX_INIT(bank->user_bank_lock);
942     }
943     return status;
944 }

```

924: bank数组保存在accel\_dev-&gt;banks，最大数量是accel\_dev-&gt;maxNumBanks\(这个数字是16\);

925-941: 这段代码只是初始化了bank-&gt;user\_bank\_lock

```c
187 STATIC CpaStatus adf_proxy_populate_device_info(icp_accel_dev_t *accel_dev)
188 {
189     return adf_proxy_populate_bank_ring_info(accel_dev);
190 }
```

```c
134 static void adf_proxy_set_bank_default_info(icp_accel_dev_t *dev)
135 {
136     adf_dev_bank_handle_t *banks = dev->banks;
137     int32_t i;
138 
139     for (i = 0; i < dev->maxNumBanks; i++, banks++)
140     {
141         banks->bank_number = i;
142         banks->bank_offset = 0;
143         banks->tx_rings_mask = 0xff;
144         banks->ring_mask = 0;
145     }
146 }
147 
148 STATIC CpaStatus adf_proxy_populate_bank_ring_info(icp_accel_dev_t *accel_dev)
149 {
150     adf_dev_bank_handle_t *bankHandler;
151     Cpa32U *inflight;
152     Cpa32U numOfBanksPerDevice = 0;
153     Cpa32U size = 0;
154     Cpa32U device_id = 0;
155 
156     device_id = accel_dev->accelId;
157     numOfBanksPerDevice = accel_dev->maxNumBanks;
158 
159     /* allocate bank handler array */
160     size = sizeof(adf_dev_bank_handle_t) * numOfBanksPerDevice;
161     bankHandler = ICP_MALLOC_GEN(size);
162     if (NULL == bankHandler)
163     {
164         ADF_ERROR("Failed to allocate memory - bankHandler\n");
165         return CPA_STATUS_FAIL;
166     }
167     ICP_MEMSET(bankHandler, 0, size);
168     accel_dev->banks = bankHandler;
169     adf_proxy_set_bank_default_info(accel_dev);
170 
171     /* allocate ring inflight array ring put/get optimization */
172     size = sizeof(*inflight) * (accel_dev->maxNumRingsPerBank >> 1) *
173            numOfBanksPerDevice;
174     inflight = ICP_MALLOC_GEN(size);
175     if (NULL == inflight)
176     {
177         ADF_ERROR("Failed to allocate memory - ringInflights\n");
178         ICP_FREE(accel_dev->banks);
179         return CPA_STATUS_FAIL;
180     }
181 
182     ringInflights[device_id] = inflight;
183 
184     return CPA_STATUS_SUCCESS;
185 }
186 
```

160-169: 分配并初始化bank数组;

每个device都有一个固定大小的bank数组；

## 3.5.4 cpaCyGetNumInstances



```c
2314 CpaStatus cpaCyGetNumInstances(Cpa16U *pNumInstances)                                                                                                                                                                                    
2315 {
2316     CpaStatus status = CPA_STATUS_SUCCESS;
2317     icp_accel_dev_t **pAdfInsts = NULL;
2318     icp_accel_dev_t *dev_addr = NULL;
2319     sal_t *base_addr = NULL;
2320     sal_list_t *list_temp = NULL;  
2321     Cpa16U num_accel_dev = 0;
2322     Cpa16U num_inst = 0;
2323     Cpa16U i = 0;
2324 
2325     LAC_CHECK_NULL_PARAM(pNumInstances);                                                                                                                                                                                                 
2326 
2327     /* Get the number of accel_dev in the system */
2328     status = icp_amgr_getNumInstances(&num_accel_dev);
2329     LAC_CHECK_STATUS(status);
2330 
2331     /* Allocate memory to store addr of accel_devs */
2332     pAdfInsts = osalMemAlloc(num_accel_dev * sizeof(icp_accel_dev_t *));                                                                                                                                                                 
2333     if (NULL == pAdfInsts)
2334     {
2335         LAC_LOG_ERROR("Failed to allocate dev instance memory");
2336         return CPA_STATUS_RESOURCE;
2337     }
2338     num_accel_dev = 0;   
2339     /* Get ADF to return all accel_devs that support either
2340      * symmetric or asymmetric crypto */
2341     status = icp_amgr_getAllAccelDevByCapabilities(
2342         (ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC |
2343          ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC),                                                                                                                                                                                       
2344         pAdfInsts,       
2345         &num_accel_dev); 
2346     if (CPA_STATUS_SUCCESS != status)                                                                                                                                                                                                    
2347     {
2348         LAC_LOG_ERROR("No support for crypto\n");
2349         *pNumInstances = 0;
2350         osalMemFree(pAdfInsts);        
2351         return status;
2352     }
2353 
2354     for (i = 0; i < num_accel_dev; i++)                                                                                                                                                                                                  
2355     {
2356         dev_addr = (icp_accel_dev_t *)pAdfInsts[i];
2357         if (NULL == dev_addr || NULL == dev_addr->pSalHandle)                                                                                                                                                                            
2358         {
2359             continue;
2360         }
2361 
2362         base_addr = dev_addr->pSalHandle;
2363         list_temp = base_addr->crypto_services;
2364         while (NULL != list_temp)
2365         {
2366             num_inst++;
2367             list_temp = SalList_next(list_temp);
2368         }
2369         list_temp = base_addr->asym_services;
2370         while (NULL != list_temp)
2371         {
2372             num_inst++;
2373             list_temp = SalList_next(list_temp);
2374         }
2375         list_temp = base_addr->sym_services;
2376         while (NULL != list_temp)
2377         {
2378             num_inst++;
2379             list_temp = SalList_next(list_temp);
2380         }
2381     }
2382     *pNumInstances = num_inst;
2383     osalMemFree(pAdfInsts);
2384 
2385 #ifdef ICP_TRACE
2386     if (NULL != pNumInstances)
2387     {
2388         LAC_LOG2("Called with params (0x%lx[%d])\n",
2389                  (LAC_ARCH_UINT)pNumInstances,
2390                  *pNumInstances);
2391     }
2392     else
2393     {
2394         LAC_LOG1("Called with params (0x%lx)\n", (LAC_ARCH_UINT)pNumInstances);
2395     }
2396 #endif
2397 
2398     return status;
2399 }
```

2341-2345: 调用icp\_amgr\_getAllAccelDevByCapabilities\(\)获取所有device信息;

```c
846 /*
847  * icp_amgr_getAllAccelDevByCapabilities
848  * Returns table of accel devices that are started and implement
849  * the capabilities specified in capabilitiesMask.
850  */
851 CpaStatus icp_amgr_getAllAccelDevByCapabilities(Cpa32U capabilitiesMask,
852                                                 icp_accel_dev_t **pAccel_devs,
853                                                 Cpa16U *pNumInstances)
854 {
855     icp_accel_dev_t **ptr = accel_tbl;
856     ICP_CHECK_FOR_NULL_PARAM(pAccel_devs);
857     ICP_CHECK_FOR_NULL_PARAM(pNumInstances);
858     Cpa16U i = 0;
859     
860     *pNumInstances = 0;
861     for (i = 0; i < ADF_MAX_DEVICES; i++, ptr++)
862     {
863         if (NULL != *ptr)
864         {
865             if ((*ptr)->accelCapabilitiesMask & capabilitiesMask)
866             {
867                 if ((*ptr)->adfSubsystemStatus)
868                 {
869                     pAccel_devs[(*pNumInstances)++] = (icp_accel_dev_t *)*ptr;
870                 }
871             }
872         }
873     }
874     return CPA_STATUS_SUCCESS;
875 }

```

2354-2356: 遍历所有device; 

2363-2368: 遍历crypto\_services list得到instance的数量;

2369-2374: 遍历asym\_services list累加instance的数量;

2375-2380: 遍历sym\_services list累加instance的数量;

2382: 返回结果.

## 3.5.5 cpaCyGetInstances

这个函数需要得到所有instance的handle:

```c
2405 CpaStatus cpaCyGetInstances(Cpa16U numInstances,
2406                             CpaInstanceHandle *pCyInstances)
2407 {
2408     CpaStatus status = CPA_STATUS_SUCCESS;
2409     icp_accel_dev_t **pAdfInsts = NULL;
2410     icp_accel_dev_t *dev_addr = NULL;
2411     sal_t *base_addr = NULL;
2412     sal_list_t *list_temp = NULL;
2413     Cpa16U num_accel_dev = 0;
2414     Cpa16U num_allocated_instances = 0;
2415     Cpa16U index = 0;
2416     Cpa16U i = 0;
2417 
2418 #ifdef ICP_TRACE
2419     LAC_LOG2("Called with params (%d, 0x%lx)\n",
2420              numInstances,
2421              (LAC_ARCH_UINT)pCyInstances);
2422 #endif
2423 
2424     LAC_CHECK_NULL_PARAM(pCyInstances);
2425     if (0 == numInstances)
2426     {
2427         LAC_INVALID_PARAM_LOG("NumInstances is 0");
2428         return CPA_STATUS_INVALID_PARAM;
2429     }
2430 
2431     /* Get the number of crypto instances */
2432     status = cpaCyGetNumInstances(&num_allocated_instances);
2433     if (CPA_STATUS_SUCCESS != status)
2434     {
2435         return status;
2436     }
2437 
2438     if (numInstances > num_allocated_instances)
2439     {
2440         LAC_LOG_ERROR1("Only %d crypto instances available",
2441                        num_allocated_instances);
2442         return CPA_STATUS_RESOURCE;
2443     }
2444 
2445     /* Get the number of accel devices in the system */
2446     status = icp_amgr_getNumInstances(&num_accel_dev);
2447     LAC_CHECK_STATUS(status);
2448 
2449     /* Allocate memory to store addr of accel_devs */
2450     pAdfInsts = osalMemAlloc(num_accel_dev * sizeof(icp_accel_dev_t *));
2451     if (NULL == pAdfInsts)
2452     {
2453         LAC_LOG_ERROR("Failed to allocate dev instance memory");
2454         return CPA_STATUS_RESOURCE;
2455     }
2456 
2457     num_accel_dev = 0;
2458     /* Get ADF to return all accel_devs that support either
2459      * symmetric or asymmetric crypto */
2460     status = icp_amgr_getAllAccelDevByCapabilities(
2461         (ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC |
2462          ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC),
2463         pAdfInsts,
2464         &num_accel_dev);
2465     if (CPA_STATUS_SUCCESS != status)
2466     {
2467         LAC_LOG_ERROR("No support for crypto\n");
2468         osalMemFree(pAdfInsts);
2469         return status;
2470     }
2471 
2472     for (i = 0; i < num_accel_dev; i++)
2473     {
2474         dev_addr = (icp_accel_dev_t *)pAdfInsts[i];
2475         /* Note dev_addr cannot be NULL here as numInstances = 0
2476          * is not valid and if dev_addr = NULL then index = 0 (which
2477          * is less than numInstances and status is set to _RESOURCE
2478          * above
2479          */
2480         base_addr = dev_addr->pSalHandle;
2481         if (NULL == base_addr)
2482         {
2483             continue;
2484         }
2485         list_temp = base_addr->crypto_services;
2486         while (NULL != list_temp)
2487         {
2488             if (index > (numInstances - 1))
2489             {
2490                 break;
2491             }
2492             pCyInstances[index] = SalList_getObject(list_temp);
2493             list_temp = SalList_next(list_temp);
2494             index++;
2495         }
2496         list_temp = base_addr->asym_services;
2497         while (NULL != list_temp)
2498         {
2499             if (index > (numInstances - 1))
2500             {
2501                 break;
2502             }
2503             pCyInstances[index] = SalList_getObject(list_temp);
2504             list_temp = SalList_next(list_temp);
2505             index++;
2506         }
2507         list_temp = base_addr->sym_services;
2508         while (NULL != list_temp)
2509         {
2510             if (index > (numInstances - 1))
2511             {
2512                 break;
2513             }
2514             pCyInstances[index] = SalList_getObject(list_temp);
2515             list_temp = SalList_next(list_temp);
2516             index++;
2517         }
2518     }
2519     osalMemFree(pAdfInsts);
2520 
2521     return status;
2522 }
```

1432: 得到instance的数量;

2446-2464: 获取所有device的信息;

2472-2474: 遍历device;

2080-2518: 将crypto, asym, sym service list中所有的instance指针copy到pCyInstances\[\]中.

