# 3.5 Engine Init

## 3.5.1 qat\_engine\_init\(\)

bind\_qat\(\)函数中通过ENGINE\_set\_init\_function\(e, qat\_engine\_init\);设置qat\_engine\_init\(\)为ENGINE\_init\(\)的调用函数:

```c
469 int qat_engine_init(ENGINE *e)
 470 {
 471     qat_pthread_mutex_lock();
 472     if (engine_inited) { 
 473         qat_pthread_mutex_unlock();
 474         return 1;
 475     }  
 476 
 477     DEBUG("QAT Engine initialization:\n");
 478     CRYPTO_INIT_QAT_LOG();
 479 
 480 #ifdef QAT_HW
 481     if (qat_offload) {
 482         if (!qat_init(e)) {
 483             WARN("QAT initialization Failed\n");
 484             return 0;
 485         }
 486     }
 487 #endif
 488 
 489 #ifdef QAT_SW
 490     if (!qat_offload) {
 491         if (!multibuff_init(e)) {
 492             WARN("Multibuff initialization Failed\n");
 493             return 0;
 494         }
 495     }
 496 #endif
 497    
 498     engine_inited = 1;
 499     qat_pthread_mutex_unlock();
 500    
 501     return 1;
 502 }  

```

## 3.5.2 qat\_init

```c
352 int qat_init(ENGINE *e)
353 {
354     int instNum, err;
355     CpaStatus status = CPA_STATUS_SUCCESS;
356     int ret_pthread_sigmask;
357     Cpa32U package_id = 0;
...
379     /* Initialise the QAT hardware */
380     if (CPA_STATUS_SUCCESS !=
381         icp_sal_userStart(ICPConfigSectionName_libcrypto)) {
382         WARN("icp_sal_userStart failed\n");
383         QATerr(QAT_F_QAT_INIT, QAT_R_ICP_SAL_USERSTART_FAIL);
384         pthread_key_delete(thread_local_variables);
385         qat_pthread_mutex_unlock();
386         return 0;
387     }
388 
389     /* Get the number of available instances */
390     status = cpaCyGetNumInstances(&qat_num_instances);
391     if (CPA_STATUS_SUCCESS != status) {
392         WARN("cpaCyGetNumInstances failed, status=%d\n", status);
393         QATerr(QAT_F_QAT_INIT, QAT_R_GET_NUM_INSTANCE_FAILURE);
394         qat_pthread_mutex_unlock();
395         qat_engine_finish(e);
396         return 0;
397     }
398     if (!qat_num_instances) {
399         WARN("No crypto instances found\n");
400         QATerr(QAT_F_QAT_INIT, QAT_R_INSTANCE_UNAVAILABLE);
401         qat_pthread_mutex_unlock();
402         qat_engine_finish(e);
403         return 0;
404     }
405 
406     DEBUG("Found %d Cy instances\n", qat_num_instances);
407 
408     /* Allocate memory for the instance handle array */
409     qat_instance_handles =
410         (CpaInstanceHandle *) OPENSSL_zalloc(((int)qat_num_instances) *
411                                              sizeof(CpaInstanceHandle));
412     if (NULL == qat_instance_handles) {
413         WARN("OPENSSL_zalloc() failed for instance handles.\n");
414         QATerr(QAT_F_QAT_INIT, QAT_R_INSTANCE_HANDLE_MALLOC_FAILURE);
415         qat_pthread_mutex_unlock();
416         qat_engine_finish(e);
417         return 0;
418     }
419 
420     /* Get the Cy instances */
421     status = cpaCyGetInstances(qat_num_instances, qat_instance_handles);
422     if (CPA_STATUS_SUCCESS != status) {
423         WARN("cpaCyGetInstances failed, status=%d\n", status);
424         QATerr(QAT_F_QAT_INIT, QAT_R_GET_INSTANCE_FAILURE);
425         qat_pthread_mutex_unlock();
426         qat_engine_finish(e);
427         return 0;
428     }
429 
430     if (!enable_external_polling && !enable_inline_polling) {
431 #ifndef __FreeBSD__
432         if (qat_is_event_driven()) {
433             CpaStatus status;
434             int flags;
435             int engine_fd;
436 
437             /*   Add the file descriptor to an epoll event list */
438             internal_efd = epoll_create1(0);
439             if (-1 == internal_efd) {
440                 WARN("Error creating epoll fd\n");
441                 QATerr(QAT_F_QAT_INIT, QAT_R_EPOLL_CREATE_FAILURE);
442                 qat_pthread_mutex_unlock();
443                 qat_engine_finish(e);
444                 return 0;
445             }
446 
447             for (instNum = 0; instNum < qat_num_instances; instNum++) {
448                 /*   Get the file descriptor for the instance */
449                 status =
450                     icp_sal_CyGetFileDescriptor(qat_instance_handles[instNum],
451                                                 &engine_fd);
452                 if (CPA_STATUS_FAIL == status) {
453                     WARN("Error getting file descriptor for instance\n");
454                     QATerr(QAT_F_QAT_INIT, QAT_R_GET_FILE_DESCRIPTOR_FAILURE);
455                     qat_pthread_mutex_unlock();
456                     qat_engine_finish(e);
457                     return 0;
458                 }
459                 /*   Make the file descriptor non-blocking */
460                 eng_poll_st[instNum].eng_fd = engine_fd;
461                 eng_poll_st[instNum].inst_index = instNum;
462 
463                 flags = qat_fcntl(engine_fd, F_GETFL, 0);
464                 if (qat_fcntl(engine_fd, F_SETFL, flags | O_NONBLOCK) == -1) {
465                     WARN("Failed to set engine_fd as NON BLOCKING\n");
466                     QATerr(QAT_F_QAT_INIT,
467                            QAT_R_SET_FILE_DESCRIPTOR_NONBLOCKING_FAILURE);
468                     qat_pthread_mutex_unlock();
469                     qat_engine_finish(e);
470                     return 0;
471                 }
472 
473                 eng_epoll_events[instNum].data.ptr = &eng_poll_st[instNum];
474                 eng_epoll_events[instNum].events = EPOLLIN | EPOLLET;
475                 if (-1 ==
476                     epoll_ctl(internal_efd, EPOLL_CTL_ADD, engine_fd,
477                               &eng_epoll_events[instNum])) {
478                     WARN("Error adding fd to epoll\n");
479                     QATerr(QAT_F_QAT_INIT, QAT_R_EPOLL_CTL_FAILURE);
480                     qat_pthread_mutex_unlock();
481                     qat_engine_finish(e);
482                     return 0;
483                 }
484             }
485         }
486 #endif
487     }
488 
489     /* Set translation function and start each instance */
490     for (instNum = 0; instNum < qat_num_instances; instNum++) {
491         /* Retrieve CpaInstanceInfo2 structure for that instance */
492         status = cpaCyInstanceGetInfo2(qat_instance_handles[instNum],
493                                        &qat_instance_details[instNum].qat_instance_info);
494         if (CPA_STATUS_SUCCESS != status ) {
495             WARN("cpaCyInstanceGetInfo2 failed. status = %d\n", status);
496             QATerr(QAT_F_QAT_INIT, QAT_R_GET_INSTANCE_INFO_FAILURE);
497             qat_pthread_mutex_unlock();
498             qat_engine_finish(e);
499             return 0;
500         }
501 
502         package_id = qat_instance_details[instNum].qat_instance_info.physInstId.packageId;
503         qat_accel_details[package_id].qat_accel_present = 1;
504         if (package_id >= qat_num_devices) {
505             qat_num_devices = package_id + 1;
506         }
507 
508         /* Set the address translation function */
509         status = cpaCySetAddressTranslation(qat_instance_handles[instNum],
510                                             virtualToPhysical);
511         if (CPA_STATUS_SUCCESS != status) {
512             WARN("cpaCySetAddressTranslation failed, status=%d\n", status);
513             QATerr(QAT_F_QAT_INIT, QAT_R_SET_ADDRESS_TRANSLATION_FAILURE);
514             qat_pthread_mutex_unlock();
515             qat_engine_finish(e);
516             return 0;
517         }
518 
519         /* Start the instances */
520         status = cpaCyStartInstance(qat_instance_handles[instNum]);
521         if (CPA_STATUS_SUCCESS != status) {
522             WARN("cpaCyStartInstance failed, status=%d\n", status);
523             QATerr(QAT_F_QAT_INIT, QAT_R_START_INSTANCE_FAILURE);
524             qat_pthread_mutex_unlock();
525             qat_engine_finish(e);
526             return 0;
527         }
528 
529         qat_instance_details[instNum].qat_instance_started = 1;
530         DEBUG("Started Instance No: %d Located on Device: %d\n", instNum, package_id);
531 
532 #if !defined(__FreeBSD__) && !defined(QAT_DRIVER_INTREE)
533         if (enable_sw_fallback) {
534             DEBUG("cpaCyInstanceSetNotificationCb instNum = %d\n", instNum);
535             status = cpaCyInstanceSetNotificationCb(qat_instance_handles[instNum],
536                                                     qat_instance_notification_callbackFn,
537                                                     (void *)(intptr_t)instNum);
538             if (CPA_STATUS_SUCCESS != status) {
539                 WARN("cpaCyInstanceSetNotificationCb failed, status=%d\n", status);
540                 QATerr(QAT_F_QAT_INIT, QAT_R_SET_NOTIFICATION_CALLBACK_FAILURE);
541                 qat_pthread_mutex_unlock();
542                 qat_engine_finish(e);
543                 return 0;
544             }
545         }
546 #endif
547     }
548 
549     if (!enable_external_polling && !enable_inline_polling) {
550         if (!qat_is_event_driven()) {
551             sigemptyset(&set);
552             sigaddset(&set, SIGUSR1);
553             ret_pthread_sigmask = pthread_sigmask(SIG_BLOCK, &set, NULL);
554             if (ret_pthread_sigmask != 0) {
555                 WARN("pthread_sigmask error\n");
556                 QATerr(QAT_F_QAT_INIT, QAT_R_POLLING_THREAD_SIGMASK_FAILURE);
557                 qat_pthread_mutex_unlock();
558                 qat_engine_finish(e);
559                 return 0;
560             }
561         }
562 #ifndef __FreeBSD__
563         if (qat_create_thread(&qat_polling_thread, NULL, qat_is_event_driven() ?
564                               event_poll_func : qat_timer_poll_func, NULL)) {
565 #else
566         if (qat_create_thread(&qat_polling_thread, NULL, qat_timer_poll_func, NULL)) {
567 #endif
568             WARN("Creation of polling thread failed\n");
569             QATerr(QAT_F_QAT_INIT, QAT_R_POLLING_THREAD_CREATE_FAILURE);
570             qat_polling_thread = pthread_self();
571             qat_pthread_mutex_unlock();
572             qat_engine_finish(e);
573             return 0;
574         }
575         if (qat_adjust_thread_affinity(qat_polling_thread) == 0) {
576             WARN("Setting polling thread affinity failed\n");
577             QATerr(QAT_F_QAT_INIT, QAT_R_SET_POLLING_THREAD_AFFINITY_FAILURE);
578             qat_pthread_mutex_unlock();
579             qat_engine_finish(e);
580             return 0;
581         }
582         if (!qat_is_event_driven()) {
583             while (!cleared_to_start)
584                 sleep(1);
585         }
586     }
587     return 1;
588 }
```

381: 初始化QAT hardware;

390: 调用cpaCyGetNumInstances\(\)获得instance的数量;

409: 为每个instance分配一个handle;

421: 调用cpaCyGetNumInstances\(\)填充instance数组;

## 3.5.3 icp\_sal\_userStart

```c
169 CpaStatus icp_sal_userStart(const char *process_name)                                                                                                                                                                                     
170 {
171     char name[ADF_CFG_MAX_SECTION_LEN_IN_BYTES + 1] = {0};
172     CpaStatus status = CPA_STATUS_SUCCESS;
173     pid_t pid = getpid(); 
...
192     if (0 == start_ref_count)
193     {
194         status = icp_adf_userProcessToStart(process_name, name);                                                                                                                                                                          
195 
196         if (CPA_STATUS_SUCCESS != status)                                                                                                                                                                                                 
197         {
198             LAC_LOG_DEBUG("icp_adf_userProcessToStart failed\n");
199             osalMutexUnlock(&sync_lock);   
200             osalMutexDestroy(&sync_lock);  
201             return CPA_STATUS_FAIL;    
202         }
203         status = do_userStart(name);                                                                                                                                                                                                      
204     }
...
```

### 3.5.3.1 do\_userStart

```c
145 static CpaStatus do_userStart(const char *process_name)
146 {
147     CpaStatus status = CPA_STATUS_SUCCESS;
148     status = icpSetProcessName(process_name);
149     LAC_CHECK_STATUS(status);
150     status = SalCtrl_AdfServicesRegister();
151     LAC_CHECK_STATUS(status);
152 
153     status = icp_adf_userProxyInit(process_name);
154     if (CPA_STATUS_SUCCESS != status)
155     {
156         LAC_LOG_ERROR("Failed to initialize proxy\n");
157         SalCtrl_AdfServicesUnregister();
158         return status;
159     }
160     status = SalCtrl_AdfServicesStartedCheck();
161     if (CPA_STATUS_SUCCESS != status)
162     {
163         LAC_LOG_ERROR("Failed to start services\n");
164         SalCtrl_AdfServicesUnregister();
165     }
166     return status;
167 }
```

### 3.5.3.2 icp\_adf\_userProxyInit

```c
319 CpaStatus icp_adf_userProxyInit(char const *const name)
320 {
321     CpaStatus status = CPA_STATUS_FAIL;
322     
323     ICP_CHECK_FOR_NULL_PARAM(name);
324     /* Allow the user to call init just once */
325     if (init_ctr)
326     {
327         ADF_ERROR("User proxy alreay initialized\n");
328         return status;
329     }
330     init_ctr = 1;
331     /* Connect to kernel space. */
332     status = adf_process_proxy_init();
333     if (CPA_STATUS_SUCCESS != status)
334     {
335         ADF_ERROR("adf_process_proxy_init failed\n");
336         return status;
337     }
338     if (!processes_lock)
339     {
340         if (OSAL_SUCCESS != ICP_MUTEX_INIT(&processes_lock))
341         {
342             ADF_ERROR("Mutex init failed for processes_lock\n");
343             status = CPA_STATUS_RESOURCE;
344         }
345     }
346     return status;
347 }
```

### 3.5.3.3 adf\_process\_proxy\_init

```c
275 /*
276  * adf_process_proxy_init
277  * Init process proxy and connect to kernel space.
278  * For every acceleration device in the system open
279  * events and rings interface and start event listening threads
280  */
281 STATIC CpaStatus adf_process_proxy_init(void)
282 {
283     if (adf_process_proxy_running())
284     {
285         ADF_ERROR("Proxy already running\n");
286         return CPA_STATUS_FAIL;
287     }
288 
289     if (adf_event_monitor_create() != CPA_STATUS_SUCCESS)
290         return CPA_STATUS_FAIL;
291 
292     adf_process_proxy_start();
293     if (adf_init_devices())
294     {
295         ADF_ERROR("Error initializing devices\n");
296         return CPA_STATUS_FAIL;
297     }
298 
299     return adf_proxy_get_devices();
300 }
```

### 3.5.3.4 adf\_proxy\_get\_devices

```c
492 CpaStatus adf_proxy_get_devices(void)
493 {   
494     int32_t ctr = 0;
495     Cpa32U num_dev = 0;
496 
497     if (icp_adf_get_numDevices(&num_dev))
498         return CPA_STATUS_FAIL;
499     for (ctr = 0; ctr < num_dev; ctr++)
500     {
501         if (adf_proxy_get_device(ctr))
502         {
503             ADF_ERROR("adf_proxy_get_device error ctr\n");
504             return CPA_STATUS_FAIL;
505         }
506     }
507     return CPA_STATUS_SUCCESS;
508 }   
```

### 3.5.3.5 adf\_proxy\_get\_device

```c
437 STATIC int32_t adf_proxy_get_device(int dev_id)
438 {
439     int32_t err;
440     int ring_file_hnd = 0;
441 
442     if ((dev_id >= ADF_MAX_DEVICES) || (NULL != accel_tbl[dev_id]))
443         return 0; /* Invalid dev_id or Already created. */
444 
445     if (!uio_acces_dev_exist(dev_id, NULL))
446         return 0;
447 
448     if (uio_create_accel_dev(&accel_tbl[dev_id], dev_id))
449     {
450         err = ENOMEM;
451         goto adf_proxy_get_device_exit;
452     }
453 
454     err = adf_user_transport_init(accel_tbl[dev_id]);
455     if (0 != err)
456     {
457         goto adf_proxy_get_device_init_failed;
458     }
459     adf_proxy_get_dev_events(dev_id);
460     num_of_instances++;
461 
462     /* Open ring_file_hnd for admin messages */
463     ring_file_hnd = open(ADF_CTL_DEVICE_NAME, O_RDONLY);
464     if (-1 != ring_file_hnd)
465         accel_tbl[dev_id]->ringFileHdl = ring_file_hnd;
466 
467     return 0;
468 
469 adf_proxy_get_device_init_failed:
470     free(accel_tbl[dev_id]);
471     accel_tbl[dev_id] = NULL;
472 adf_proxy_get_device_exit:
473     return err;
474 }
```

448: 为accel\_tbl\[dev\_id\]申请资源;

454: 初始化bank;

459: 初始化device event相关资源;

460: 增加num\_of\_instances来记录device的数量\(用num\_of\_instances这个名字好像不太合适\);

### 3.5.3.6 adf\_user\_transport\_init

```c
909 CpaStatus adf_user_transport_init(icp_accel_dev_t *accel_dev)
910 {
911     CpaStatus status = CPA_STATUS_SUCCESS;
912     Cpa32U i = 0;
913     Cpa32S x = 0;
914     adf_dev_bank_handle_t *bank = NULL;
915     adf_dev_bank_handle_t *banks = NULL;
916     ICP_CHECK_FOR_NULL_PARAM(accel_dev);
917 
918     status = adf_proxy_populate_device_info(accel_dev);
919     if (CPA_STATUS_SUCCESS != status)
920     {
921         return status;
922     }
923     
924     banks = accel_dev->banks;
925     for (i = 0; i < accel_dev->maxNumBanks; i++)
926     {   
927         bank = &banks[i];
928         bank->user_bank_lock = ICP_MALLOC_GEN(sizeof(ICP_MUTEX));
929         if (!bank->user_bank_lock)
930         {
931             ADF_ERROR("Could not alloc memory for bank mutex\n");
932             for (x = i - 1; x >= 0; x--)
933             {
934                 bank = &banks[x];
935                 ICP_MUTEX_UNINIT(bank->user_bank_lock);
936                 ICP_FREE(bank->user_bank_lock);
937             }
938             adf_proxy_depopulate_device_info(accel_dev);
939             return CPA_STATUS_FAIL;
940         }
941         ICP_MUTEX_INIT(bank->user_bank_lock);
942     }
943     return status;
944 }

```

924: bank数组保存在accel\_dev-&gt;banks，最大数量是accel\_dev-&gt;maxNumBanks\(这个数字是16\);

925-941: 这段代码只是初始化了bank-&gt;user\_bank\_lock

```c
187 STATIC CpaStatus adf_proxy_populate_device_info(icp_accel_dev_t *accel_dev)
188 {
189     return adf_proxy_populate_bank_ring_info(accel_dev);
190 }
```

```c
134 static void adf_proxy_set_bank_default_info(icp_accel_dev_t *dev)
135 {
136     adf_dev_bank_handle_t *banks = dev->banks;
137     int32_t i;
138 
139     for (i = 0; i < dev->maxNumBanks; i++, banks++)
140     {
141         banks->bank_number = i;
142         banks->bank_offset = 0;
143         banks->tx_rings_mask = 0xff;
144         banks->ring_mask = 0;
145     }
146 }
147 
148 STATIC CpaStatus adf_proxy_populate_bank_ring_info(icp_accel_dev_t *accel_dev)
149 {
150     adf_dev_bank_handle_t *bankHandler;
151     Cpa32U *inflight;
152     Cpa32U numOfBanksPerDevice = 0;
153     Cpa32U size = 0;
154     Cpa32U device_id = 0;
155 
156     device_id = accel_dev->accelId;
157     numOfBanksPerDevice = accel_dev->maxNumBanks;
158 
159     /* allocate bank handler array */
160     size = sizeof(adf_dev_bank_handle_t) * numOfBanksPerDevice;
161     bankHandler = ICP_MALLOC_GEN(size);
162     if (NULL == bankHandler)
163     {
164         ADF_ERROR("Failed to allocate memory - bankHandler\n");
165         return CPA_STATUS_FAIL;
166     }
167     ICP_MEMSET(bankHandler, 0, size);
168     accel_dev->banks = bankHandler;
169     adf_proxy_set_bank_default_info(accel_dev);
170 
171     /* allocate ring inflight array ring put/get optimization */
172     size = sizeof(*inflight) * (accel_dev->maxNumRingsPerBank >> 1) *
173            numOfBanksPerDevice;
174     inflight = ICP_MALLOC_GEN(size);
175     if (NULL == inflight)
176     {
177         ADF_ERROR("Failed to allocate memory - ringInflights\n");
178         ICP_FREE(accel_dev->banks);
179         return CPA_STATUS_FAIL;
180     }
181 
182     ringInflights[device_id] = inflight;
183 
184     return CPA_STATUS_SUCCESS;
185 }
186 
```

160-169: 分配并初始化bank数组;

每个device都有一个固定大小的bank数组；

### 3.5.3.7 adf\_proxy\_get\_dev\_events

```c
476 STATIC int adf_proxy_get_dev_events(int dev_id)
477 {
478     enum adf_event event[] = {ADF_EVENT_INIT, ADF_EVENT_START};
479     size_t i = 0;
480 
481     if (accel_tbl[dev_id] != NULL)
482     {
483         for (i = 0; i < sizeof(event) / sizeof(event[0]); i++)
484         {
485             subsystem_notify(dev_id, event[i]);
486         }
487     }
488 
489     return 0;
490 }
```

Init then start subsystem of each device.

```c
317 STATIC CpaStatus subsystem_notify(Cpa32U accelId, Cpa32U event)
318 {
319     CpaStatus stat = CPA_STATUS_SUCCESS;
320     CpaStatus stat_proxy = CPA_STATUS_SUCCESS;
321     CpaStatus stat_restart = CPA_STATUS_SUCCESS;
322     icp_accel_dev_t *accel_dev;
323 
324     accel_dev = accel_tbl[accelId];
325     if (!accel_dev && event != ADF_EVENT_RESTARTED)
326         return CPA_STATUS_INVALID_PARAM;
327 
328     switch (event)
329     {
330         case ADF_EVENT_INIT:
331             if (accel_dev_sal_hdl_ptr[accel_dev->accelId])
332             {
333                 accel_dev->pSalHandle =
334                     accel_dev_sal_hdl_ptr[accel_dev->accelId];
335                 accel_dev_sal_hdl_ptr[accel_dev->accelId] = NULL;
336             }
337             stat = adf_user_subsystemInit(accel_dev);
338             break;
339         case ADF_EVENT_START:
340             stat = adf_user_subsystemStart(accel_dev);
341             adf_start_system(accel_dev);
342             if (accel_dev_reset_stat[accel_dev->accelId])
343             {
344                 accel_dev_reset_stat[accel_dev->accelId] = 0;
345                 stat_restart = adf_subsystemRestarted(accel_dev);
346             }
347             accel_dev_error_stat[accel_dev->accelId] = 0;
348             break;
349         case ADF_EVENT_STOP:
...
```

### 3.5.3.8 Service Init

```c
317 CpaStatus adf_user_subsystemInit(icp_accel_dev_t *accel_dev)
318 {
319     CpaStatus status = CPA_STATUS_FAIL;
320     subservice_registation_handle_t *subsystem_hdl = pSubsystemTableHead;
321     ICP_CHECK_FOR_NULL_PARAM(accel_dev);
322 
323     while (NULL != subsystem_hdl)
324     {
325         ADF_DEBUG("Sending event %d to %s\n",
326                   ADF_EVENT_INIT,
327                   subsystem_hdl->subsystem_name);
328 
329         CLEAR_STATUS_BIT(subsystem_hdl->subsystemStatus[accel_dev->accelId]
330                              .subsystemFailedBit,
331                          0);
332 
333         status = subsystem_hdl->subserviceEventHandler(
334             accel_dev, ADF_EVENT_INIT, NULL);
335         if (CPA_STATUS_SUCCESS == status)
336         {
337             SET_STATUS_BIT(subsystem_hdl->subsystemStatus[accel_dev->accelId]
338                                .subsystemInitBit,
339                            0);
340         }
341         else
342         {
343             ADF_ERROR("Failed to initialise Subservice %s\n",
344                       subsystem_hdl->subsystem_name);
345             SET_STATUS_BIT(subsystem_hdl->subsystemStatus[accel_dev->accelId]
346                                .subsystemFailedBit,
347                            0);
348             return status;
349         }
350         subsystem_hdl = subsystem_hdl->pNext;
351     }
352     return status;
353 }
```

333-334: subsystem\_hdl-&gt;subserviceEventHandler指向的函数是SalCtrl\_ServiceEventHandler\(\):

```c
1443 STATIC CpaStatus SalCtrl_ServiceEventHandler(icp_accel_dev_t *device,
1444                                              enum adf_event event,
1445                                              void *param)
1446 {
1447     CpaStatus status = CPA_STATUS_SUCCESS;
1448     CpaStatus stats_status = CPA_STATUS_SUCCESS;
1449     Cpa32U enabled_services = 0;
1450 
1451     status = SalCtrl_GetEnabledServices(device, &enabled_services);
1452     if (CPA_STATUS_SUCCESS != status)
1453     {
1454         LAC_LOG_ERROR("Failed to get enabled services");
1455         return status;
1456     }
1457 
1458     switch (event)
1459     {
1460         case ADF_EVENT_INIT:
1461         {
1462             /* In case there is no QAT SAL needs to call InitStats */
1463             if (NULL == device->pQatStats)
1464             {
1465                 status = SalStatistics_InitStatisticsCollection(device);
1466             }
1467             if (CPA_STATUS_SUCCESS != status)
1468             {
1469                 return status;
1470             }
1471             status = SalCtrl_ServiceEventInit(device, enabled_services);
1472             break;
1473         }
1474         case ADF_EVENT_START:
1475         {
1476             status = SalCtrl_ServiceEventStart(device, enabled_services);
1477             break;
1478         }
1479         case ADF_EVENT_STOP:
...
```

```c
1045 STATIC CpaStatus SalCtrl_ServiceEventInit(icp_accel_dev_t *device,
1046                                           Cpa32U enabled_services)
1047 {
1048     sal_t *service_container = NULL;
1049     CpaStatus status = CPA_STATUS_SUCCESS;
1050     sal_list_t *tail_list = NULL;
1051     Cpa32U instance_count = 0;
1052 
1053     status = SalCtrl_GetSupportedServices(device, enabled_services);
1054     if (CPA_STATUS_SUCCESS != status)
1055     {
1056         LAC_LOG_ERROR("Failed to get supported services");
1057         return status;
1058     }
1059 
1060     if (!icp_adf_is_dev_in_reset(device))
1061     {
1062         service_container = osalMemAlloc(sizeof(sal_t));
1063         if (NULL == service_container)
1064         {
1065             LAC_LOG_ERROR("Failed to allocate service memory");
1066             return CPA_STATUS_RESOURCE;
1067         }
1068         device->pSalHandle = service_container;
1069         service_container->asym_services = NULL;
1070         service_container->sym_services = NULL;
1071         service_container->crypto_services = NULL;
1072         service_container->compression_services = NULL;
1073     }
1074     else
1075     {
1076         service_container = device->pSalHandle;
1077     }
1078     service_container->asym_dir = NULL;
1079     service_container->sym_dir = NULL;
1080     service_container->cy_dir = NULL;
1081     service_container->dc_dir = NULL;
1082     service_container->ver_file = NULL;
1083 
1084     status =
1085         LAC_OS_MALLOC(&service_container->ver_file, sizeof(debug_file_info_t));
1086     if (CPA_STATUS_SUCCESS != status)
1087     {
1088         osalMemFree(service_container);
1089         return status;
1090     }
1091 
1092     osalMemSet(service_container->ver_file, 0, sizeof(debug_file_info_t));
1093     service_container->ver_file->name = ver_file_name;
1094     service_container->ver_file->seq_read = SalCtrl_VersionDebug;
1095     service_container->ver_file->private_data = device;
1096     service_container->ver_file->parent = NULL;
1097 
1098 #ifndef ICP_DC_ONLY
1099     if (SalCtrl_IsServiceEnabled(enabled_services,
1100                                  SAL_SERVICE_TYPE_CRYPTO_ASYM))
1101     {
1102         status = SalCtrl_GetInstanceCount(
1103             device, "NumberCyInstances", &instance_count);
1104         if (CPA_STATUS_SUCCESS != status)
1105         {
1106             instance_count = 0;
1107         }
1108         status = SalCtrl_ServiceInit(device,
1109                                      &service_container->asym_services,
1110                                      &service_container->asym_dir,
1111                                      asym_dir_name,
1112                                      tail_list,
1113                                      instance_count,
1114                                      SAL_SERVICE_TYPE_CRYPTO_ASYM);
1115         if (CPA_STATUS_SUCCESS != status)
1116         {
1117             goto err_init;
1118         }
1119     }
1120 
1121     if (SalCtrl_IsServiceEnabled(enabled_services, SAL_SERVICE_TYPE_CRYPTO_SYM))
1122     {
1123         status = SalCtrl_GetInstanceCount(
1124             device, "NumberCyInstances", &instance_count);
1125         if (CPA_STATUS_SUCCESS != status)
1126         {
1127             instance_count = 0;
1128         }
1129         status = SalCtrl_ServiceInit(device,
1130                                      &service_container->sym_services,
1131                                      &service_container->sym_dir,
...
```

1062-1072: 初始化device-&gt;pSalHandle;

1099-1114: 初始化ASYM service;

1121-1135: 初始化SYM service;

1142-1156: 初始化CRYPTO service;

```c
 565 STATIC CpaStatus SalCtrl_ServiceInit(icp_accel_dev_t *device,
 566                                      sal_list_t **services,
 567                                      debug_dir_info_t **dbg_dir,
 568                                      char *dbg_dir_name,
 569                                      sal_list_t *tail_list,
 570                                      Cpa32U instance_count,
 571                                      sal_service_type_t svc_type)
 572 {
 573     CpaStatus status = CPA_STATUS_SUCCESS;
 574     sal_service_t *pInst = NULL;
 575     Cpa32U i = 0;
 576     debug_dir_info_t *debug_dir = NULL;
 577 
 578     status = LAC_OS_MALLOC(&debug_dir, sizeof(debug_dir_info_t));
 579     if (CPA_STATUS_SUCCESS != status)
 580     {
 581         LAC_LOG_ERROR("Failed to allocate memory for debug dir");
 582         return status;
 583     }
 584     debug_dir->name = dbg_dir_name;
 585     debug_dir->parent = NULL;
 586 
 587     if (!icp_adf_is_dev_in_reset(device))
 588     {
 589         for (i = 0; i < instance_count; i++)
 590         {
 591             status = SalCtrl_ServiceCreate(svc_type, i, &pInst);
 592             if (CPA_STATUS_SUCCESS != status)
 593             {
 594                 break;
 595             }
 596             pInst->debug_parent_dir = debug_dir;
 597             pInst->capabilitiesMask = device->accelCapabilitiesMask;
 598             status = SalList_add(services, &tail_list, pInst);
 599             if (CPA_STATUS_SUCCESS != status)
 600             {
 601                 osalMemFree(pInst);
 602             }
 603         }
 604     }
 605     else
 606     {
 607         sal_list_t *curr_element = *services;
 608         sal_service_t *service = NULL;
 609         while (NULL != curr_element)
 610         {
 611             service = (sal_service_t *)SalList_getObject(curr_element);
 612             service->debug_parent_dir = debug_dir;
 613 
 614             if (CPA_TRUE == service->isInstanceStarted)
 615             {
 616                 icp_qa_dev_get(device);
 617             }
 618 
 619             curr_element = SalList_next(curr_element);
 620         }
 621     }
 622 
 623     if (CPA_STATUS_SUCCESS != status)
 624     {
 625         LAC_LOG_ERROR("Failed to allocate all instances");
 626         LAC_OS_FREE(debug_dir);
 627         debug_dir = NULL;
 628         SalList_free(services);
 629         return status;
 630     }
 631 
 632     /* Call init function for each service instance */
 633     SAL_FOR_EACH(*services, sal_service_t, device, init, status);
 634     if (CPA_STATUS_SUCCESS != status)
 635     {
 636         LAC_LOG_ERROR("Failed to initialise all service instances");
 637         /* shutdown all instances initialised before error */
 638         SAL_FOR_EACH_STATE(*services,
 639                            sal_service_t,
 640                            device,
 641                            shutdown,
 642                            SAL_SERVICE_STATE_INITIALIZED);
 643         LAC_OS_FREE(debug_dir);
 644         debug_dir = NULL;
 645         SalList_free(services);
 646         return status;
 647     }
 648     /* initialize the debug directory for relevant service */
 649     *dbg_dir = debug_dir;
 650 
 651     return status;
 652 }
```

589-601: 调用SalCtrl\_ServiceCreate\(\)生成指定数量\(instance\_count, 由配置文件中的"NumberCyInstances"决定\)的instance, 并把它加入到service队列中; 对于SAL\_SERVICE\_TYPE\_CRYPTO, 这个队列就是\(\(icp\_accel\_dev\_t \*\)device\)-&gt;pSalHandle-&gt;crypto\_services;

```c
 97 CpaStatus SalCtrl_ServiceCreate(sal_service_type_t serviceType,
 98                                 Cpa32U instance,
 99                                 sal_service_t **ppInst)
100 {
101 #ifndef ICP_DC_ONLY
102     sal_crypto_service_t *pCrypto_service = NULL;
103 #endif
104     sal_compression_service_t *pCompression_service = NULL;
105 
106     switch ((sal_service_type_t)serviceType)
107     {
108 #ifndef ICP_DC_ONLY
109         case SAL_SERVICE_TYPE_CRYPTO_ASYM:
110         case SAL_SERVICE_TYPE_CRYPTO_SYM:
111         case SAL_SERVICE_TYPE_CRYPTO:
112         {
113             pCrypto_service = osalMemAlloc(sizeof(sal_crypto_service_t));
114             if (NULL == pCrypto_service)
115             {
116                 LAC_LOG_ERROR("Failed to allocate crypto service memory");
117                 *(ppInst) = NULL;
118                 return CPA_STATUS_RESOURCE;
119             }
120 
121             /* Zero memory */
122             osalMemSet(pCrypto_service, 0, sizeof(sal_crypto_service_t));
123 
124             pCrypto_service->generic_service_info.type =
125                 (sal_service_type_t)serviceType;
126             pCrypto_service->generic_service_info.state =
127                 SAL_SERVICE_STATE_UNINITIALIZED;
128             pCrypto_service->generic_service_info.instance = instance;
129 
130             pCrypto_service->generic_service_info.init = SalCtrl_CryptoInit;
131             pCrypto_service->generic_service_info.start = SalCtrl_CryptoStart;
132             pCrypto_service->generic_service_info.stop = SalCtrl_CryptoStop;
133             pCrypto_service->generic_service_info.shutdown =
134                 SalCtrl_CryptoShutdown;
135             pCrypto_service->generic_service_info.error = SalCtrl_CryptoError;
136 
137             *(ppInst) = &(pCrypto_service->generic_service_info);
138 
139             return CPA_STATUS_SUCCESS;
140         }
141 #endif
142         case SAL_SERVICE_TYPE_COMPRESSION:

```

633: Call init function for each service instance.

```c
150 #define SAL_FOR_EACH(list, type, device, function, status_ret)                 \
151     do                                                                         \
152     {                                                                          \
153         sal_list_t *curr_element = list;                                       \
154         CpaStatus status_temp = CPA_STATUS_SUCCESS;                            \
155         type *process = NULL;                                                  \
156         while (NULL != curr_element)                                           \
157         {                                                                      \
158             process = (type *)SalList_getObject(curr_element);                 \
159             status_temp = process->function(device, process);                  \
160             if ((CPA_STATUS_SUCCESS != status_temp) &&                         \
161                 (CPA_STATUS_RETRY != status_temp))                             \
162             {                                                                  \
163                 status_ret = status_temp;                                      \
164                 break;                                                         \
165             }                                                                  \
166             else                                                               \
167             {                                                                  \
168                 if (CPA_STATUS_RETRY == status_temp)                           \
169                 {                                                              \
170                     status_ret = status_temp;                                  \
171                 }                                                              \
172             }                                                                  \
173             curr_element = SalList_next(curr_element);                         \
174         }                                                                      \
175     } while (0) 
```

159: 由SalCtrl\_ServiceCreate\(\)函数的代码可知init函数是SalCtrl\_CryptoInit\(\):

```c
1876 /* This function:
1877  * 1. Creates sym and asym transport handles
1878  * 2. Allocates memory pools required by sym and asym services
1879 .* 3. Clears the sym and asym stats counters
1880  * 4. In case service asym or sym is enabled then this function
1881  *    only allocates resources for these services. i.e if the
1882  *    service asym is enabled then only asym transport handles
1883  *    are created and vice versa.
1884  */
1885 CpaStatus SalCtrl_CryptoInit(icp_accel_dev_t *device, sal_service_t *service)
1886 {
1887     CpaStatus status = CPA_STATUS_SUCCESS;
1888     sal_crypto_service_t *pCryptoService = (sal_crypto_service_t *)service;
1889     sal_service_type_t svc_type = service->type;
1890 
1891     SAL_SERVICE_GOOD_FOR_INIT(pCryptoService);
1892     pCryptoService->generic_service_info.state = SAL_SERVICE_STATE_INITIALIZING;
1893 
1894     /* Set up the instance parameters such as bank number,
1895      * coreAffinity, pkgId and node affinity etc
1896      */
1897     status = SalCtr_InstInit(device, service);
1898     LAC_CHECK_STATUS(status);
1899 
1900     /* Create debug directory for service */
1901     status = SalCtrl_DebugInit(device, service);
1902     LAC_CHECK_STATUS(status);
1903 
1904     switch (svc_type)
1905     {
1906 #ifndef ASYM_NOT_SUPPORTED
1907         case SAL_SERVICE_TYPE_CRYPTO_ASYM:
1908             status = SalCtrl_AsymInit(device, service);
1909             if (CPA_STATUS_SUCCESS != status)
1910             {
1911                 SalCtrl_DebugShutdown(device, service);
1912                 return status;
1913             }
1914             break;
1915 #endif
1916         case SAL_SERVICE_TYPE_CRYPTO_SYM:
1917             status = SalCtrl_SymInit(device, service);
1918             if (CPA_STATUS_SUCCESS != status)
1919             {
1920                 SalCtrl_DebugShutdown(device, service);
1921                 return status;
1922             }
1923             break;
1924         case SAL_SERVICE_TYPE_CRYPTO:
1925 #ifndef ASYM_NOT_SUPPORTED
1926             status = SalCtrl_AsymInit(device, service);
1927             if (CPA_STATUS_SUCCESS != status)
1928             {
1929                 SalCtrl_DebugShutdown(device, service);
1930                 return status;
1931             }
1932 #endif
1933             status = SalCtrl_SymInit(device, service);
1934             if (CPA_STATUS_SUCCESS != status)
1935             {
1936                 SalCtrl_DebugShutdown(device, service);
1937 #ifndef ASYM_NOT_SUPPORTED
1938                 SalCtrl_AsymFreeResources(pCryptoService);
1939 #endif
1940                 return status;
1941             }
1942             break;
1943         default:
1944             LAC_LOG_ERROR("Invalid service type\n");
1945             status = CPA_STATUS_FAIL;
1946             break;
1947     }
1948 
1949     pCryptoService->generic_service_info.state = SAL_SERVICE_STATE_INITIALIZED;
1950 #ifdef KPT
1951     osalAtomicSet(0, &(pCryptoService->kpt_keyhandle_loaded));
1952     pCryptoService->maxNumKptKeyHandle =
1953         KPTKSP_REGISTER_KEY_HANDLE_MAXIMUM_NUMBER;
1954 #endif
1955 
1956     return status;
1957 }
```

1924: CRYPTO是同时支持ASYM和SYM的一种模式. SalCtrl\_AsymInit\(\):

```c
1362 STATIC CpaStatus SalCtrl_AsymInit(icp_accel_dev_t *device,
1363                                   sal_service_t *service)
1364 {
1365     CpaStatus status = CPA_STATUS_SUCCESS;
1366     Cpa32U numAsymConcurrentReq = 0;
1367     char adfGetParam[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {0};
1368     char temp_string[SAL_CFG_MAX_VAL_LEN_IN_BYTES] = {0};
1369     sal_crypto_service_t *pCryptoService = (sal_crypto_service_t *)service;
1370     char *section = DYN_SEC;
1371 
1372     /* Instance may not in the DYN section */
1373     if (CPA_FALSE == pCryptoService->generic_service_info.is_dyn)
1374     {
1375         section = icpGetProcessName();
1376     }
1377 
1378     /* get num concurrent requests from config file */
1379     status = Sal_StringParsing("Cy",
1380                                pCryptoService->generic_service_info.instance,
1381                                "NumConcurrentAsymRequests",
1382                                temp_string);
1383     LAC_CHECK_STATUS(status);
1384     status =
1385         icp_adf_cfgGetParamValue(device, section, temp_string, adfGetParam);
1386     if (CPA_STATUS_SUCCESS != status)
1387     {
1388         LAC_LOG_STRING_ERROR1("Failed to get %s from configuration file",
1389                               temp_string);
1390         return status;
1391     }
1392 
1393     numAsymConcurrentReq =
1394         (Cpa32U)Sal_Strtoul(adfGetParam, NULL, SAL_CFG_BASE_DEC);
1395     if (CPA_STATUS_FAIL == validateConcurrRequest(numAsymConcurrentReq))
1396     {
1397         LAC_LOG_ERROR("Invalid NumConcurrentAsymRequests, valid "
1398                       "values {64, 128, 256, 512, .. 32768, 65536}");
1399         return CPA_STATUS_FAIL;
1400     }
1401 
1402     /* Create transport handles */
1403     status = SalCtrl_AsymCreateTransHandle(
1404         device, service, numAsymConcurrentReq, section);
1405     LAC_CHECK_STATUS(status);
1406 
1407     /* Allocates memory pools */
1408     pCryptoService->lac_pke_align_pool = LAC_MEM_POOL_INIT_POOL_ID;
1409     status = Sal_StringParsing("Cy",
1410                                pCryptoService->generic_service_info.instance,
1411                                "AsymResizePool",
1412                                temp_string);
1413     LAC_CHECK_STATUS_ASYM_INIT(status);
1414     status = Lac_MemPoolCreate(
1415         &pCryptoService->lac_pke_align_pool,
1416         temp_string,
1417         (((numAsymConcurrentReq + 1)) * LAC_PKE_BUFFERS_PER_OP_MAX),
1418         LAC_BITS_TO_BYTES(LAC_MAX_OP_SIZE_IN_BITS),
1419         LAC_64BYTE_ALIGNMENT,
1420         CPA_FALSE,
1421         pCryptoService->nodeAffinity);
1422     LAC_CHECK_STATUS_ASYM_INIT(status);
1423 
1424     /* Allocate pke request memory pool */
1425     pCryptoService->lac_pke_req_pool = LAC_MEM_POOL_INIT_POOL_ID;
1426     status = Sal_StringParsing("Cy",
1427                                pCryptoService->generic_service_info.instance,
1428                                "AsymReqPool",
1429                                temp_string);
1430     LAC_CHECK_STATUS_ASYM_INIT(status);
1431     status = Lac_MemPoolCreate(
1432         &(pCryptoService->lac_pke_req_pool),
1433         temp_string,
1434         (((numAsymConcurrentReq + 1)) * LAC_PKE_MAX_CHAIN_LENGTH),
1435         sizeof(lac_pke_qat_req_data_t),
1436         LAC_64BYTE_ALIGNMENT,
1437         CPA_TRUE,
1438         pCryptoService->nodeAffinity);
1439     LAC_CHECK_STATUS_ASYM_INIT(status);
1440 
1441     /* Allocate prime memory pool */
1442     pCryptoService->lac_prime_pool = LAC_MEM_POOL_INIT_POOL_ID;
1443     status = Sal_StringParsing("Cy",
1444                                pCryptoService->generic_service_info.instance,
1445                                "AsymPrimePool",
1446                                temp_string);
1447     LAC_CHECK_STATUS_ASYM_INIT(status);
1448     status = Lac_MemPoolCreate(&pCryptoService->lac_prime_pool,
1449                                temp_string,
1450                                (numAsymConcurrentReq * 2 + 1),
1451                                (sizeof(CpaFlatBuffer) * (LAC_PRIME_MAX_MR + 1)),
1452                                LAC_64BYTE_ALIGNMENT,
1453                                CPA_FALSE,
1454                                pCryptoService->nodeAffinity);
1455     LAC_CHECK_STATUS_ASYM_INIT(status);
1456 
1457     /* Allocate EC memory pool */
1458     pCryptoService->lac_ec_pool = LAC_MEM_POOL_INIT_POOL_ID;
1459     status = Sal_StringParsing("Cy",
1460                                pCryptoService->generic_service_info.instance,
1461                                "AsymEcMemPool",
1462                                temp_string);
1463     LAC_CHECK_STATUS_ASYM_INIT(status);
1464     status =
1465         Lac_MemPoolCreate(&pCryptoService->lac_ec_pool,
1466                           temp_string,
1467                           ((numAsymConcurrentReq + 1)),
1468                           ((LAC_EC_NUM_CONCAT_INPUTS * LAC_EC_SIZE_BYTES_MAX) +
1469                            sizeof(CpaFlatBuffer)),
1470                           LAC_64BYTE_ALIGNMENT,
1471                           CPA_FALSE,
1472                           pCryptoService->nodeAffinity);
1473     LAC_CHECK_STATUS_ASYM_INIT(status);
1474 
1475 #ifdef KPT
1476     pCryptoService->lac_kpt_pool = LAC_MEM_POOL_INIT_POOL_ID;
1477     status = Sal_StringParsing("Cy",
1478                                pCryptoService->generic_service_info.instance,
1479                                "AsymKptMemPool",
1480                                temp_string);
1481     LAC_CHECK_STATUS_ASYM_INIT(status);
1482     status =
1483         Lac_MemPoolCreate(&pCryptoService->lac_kpt_pool,
1484                           temp_string,
1485                           ((numAsymConcurrentReq + 1) * LAC_KPT_POOL_SIZE_MAX),
1486                           (LAC_KPT_SIZE_BYTES_MAX + sizeof(CpaFlatBuffer)),
1487                           LAC_64BYTE_ALIGNMENT,
1488                           CPA_FALSE,
1489                           pCryptoService->nodeAffinity);
1490     LAC_CHECK_STATUS_ASYM_INIT(status);
1491 
1492     pCryptoService->lac_kpt_array_pool = LAC_MEM_POOL_INIT_POOL_ID;
1493     status = Sal_StringParsing("Cy",
1494                                pCryptoService->generic_service_info.instance,
1495                                "AsymKptMemArrayPool",
1496                                temp_string);
1497     LAC_CHECK_STATUS_ASYM_INIT(status);
1498     status = Lac_MemPoolCreate(&pCryptoService->lac_kpt_array_pool,
1499                                temp_string,
1500                                (numAsymConcurrentReq + 1),
1501                                (LAC_KPT_POOL_SIZE_MAX * sizeof(LAC_ARCH_UINT)),
1502                                LAC_64BYTE_ALIGNMENT,
1503                                CPA_FALSE,
1504                                pCryptoService->nodeAffinity);
1505     LAC_CHECK_STATUS_ASYM_INIT(status);
1506 #endif
1507 
1508     /* Clear Key stats and allocate memory of SSL and TLS labels
1509         These labels are initialised to standard values */
1510 
1511     /* Init DH stats */
1512     status = LacDh_Init(pCryptoService);
1513     LAC_CHECK_STATUS_ASYM_INIT(status);
1514 
1515     /* Init Dsa stats */
1516     status = LacDsa_Init(pCryptoService);
1517     LAC_CHECK_STATUS_ASYM_INIT(status);
1518 
1519     /* Init Ec stats */
1520     status = LacEc_Init(pCryptoService);
1521     LAC_CHECK_STATUS_ASYM_INIT(status);
1522 
1523     /* Init Ln Stats */
1524     status = LacLn_Init(pCryptoService);
1525     LAC_CHECK_STATUS_ASYM_INIT(status);
1526 
1527     /* Init Prime stats */
1528     status = LacPrime_Init(pCryptoService);
1529     LAC_CHECK_STATUS_ASYM_INIT(status);
1530 
1531     /* Init Rsa Stats */
1532     status = LacRsa_Init(pCryptoService);
1533     LAC_CHECK_STATUS_ASYM_INIT(status);
1534 
1535     /* Build Flow ID for all pke request sent on this instance */
1536     pCryptoService->pkeFlowId =
1537         (LAC_PKE_FLOW_ID_TAG |
1538          (pCryptoService->acceleratorNum << LAC_PKE_ACCEL_ID_BIT_POS) |
1539          (pCryptoService->executionEngine << LAC_PKE_SLICE_ID_BIT_POS));
1540 
1541     /* For all asym requests fill out known data */
1542     Lac_MemPoolInitAsymCookies(pCryptoService->lac_pke_req_pool,
1543                                pCryptoService);
1544 
1545     return status;
1546 }
```

1379-1394: 解析配置文件部分参数;

1403-1404: Create transport handles;

1414-1504: Create Mem Pool for all the cipher operations.

```c
 542 /* Function that creates the Asym Handles. */
 543 STATIC CpaStatus SalCtrl_AsymCreateTransHandle(icp_accel_dev_t *device,
 544                                                sal_service_t *service,
 545                                                Cpa32U numAsymRequests,
 546                                                char *section)
 547 {
 548     CpaStatus status = CPA_STATUS_SUCCESS;
 549     char temp_string[SAL_CFG_MAX_VAL_LEN_IN_BYTES] = {0};
 550     sal_crypto_service_t *pCryptoService = (sal_crypto_service_t *)service;
 551     icp_resp_deliv_method rx_resp_type = ICP_RESP_TYPE_IRQ;
 552     Cpa32U msgSize = 0;
 553 
 554     if (SAL_RESP_POLL_CFG_FILE == pCryptoService->isPolled)
 555     {
 556         rx_resp_type = ICP_RESP_TYPE_POLL;
 557     }
 558 
 559     if (CPA_FALSE == pCryptoService->generic_service_info.is_dyn)
 560     {
 561         section = icpGetProcessName();
 562     }
 563 
 564     /* Parse Asym ring details first */
 565     status = Sal_StringParsing("Cy",
 566                                pCryptoService->generic_service_info.instance,
 567                                "RingAsymTx",
 568                                temp_string);
 569     /* Need to free resources in case not _SUCCESS from here */
 570     LAC_CHECK_STATUS_ASYM_INIT(status);
 571 
 572     msgSize = LAC_QAT_ASYM_REQ_SZ_LW * LAC_LONG_WORD_IN_BYTES;
 573     status = icp_adf_transCreateHandle(
 574         device,
 575         ICP_TRANS_TYPE_ETR,
 576         section,
 577         pCryptoService->acceleratorNum,
 578         pCryptoService->bankNum,
 579         temp_string,
 580         lac_getRingType(SAL_RING_TYPE_A_ASYM),
 581         NULL,
 582         ICP_RESP_TYPE_NONE,
 583         numAsymRequests,
 584         msgSize,
 585         (icp_comms_trans_handle *)&(pCryptoService->trans_handle_asym_tx));
 586     LAC_CHECK_STATUS_ASYM_INIT(status);
 587 
 588     status = Sal_StringParsing("Cy",
 589                                pCryptoService->generic_service_info.instance,
 590                                "RingAsymRx",
 591                                temp_string);
 592     LAC_CHECK_STATUS_ASYM_INIT(status);
 593 
 594     msgSize = LAC_QAT_ASYM_RESP_SZ_LW * LAC_LONG_WORD_IN_BYTES;
 595     status = icp_adf_transCreateHandle(
 596         device,
 597         ICP_TRANS_TYPE_ETR,
 598         section,
 599         pCryptoService->acceleratorNum,
 600         pCryptoService->bankNum,
 601         temp_string,
 602         lac_getRingType(SAL_RING_TYPE_NONE),
 603         LacPke_MsgCallback,
 604         rx_resp_type,
 605         numAsymRequests,
 606         msgSize,
 607         (icp_comms_trans_handle *)&(pCryptoService->trans_handle_asym_rx));
 608     LAC_CHECK_STATUS_ASYM_INIT(status);
 609 
 610     return status;
 611 }
 612 #endif
```

调用icp\_adf\_transCreateHandle\(\)分别为Tx和Rx创建handle.

```c
241 /*
242  * Create a transport handle
243  * The function sends ioctl request to adf user proxy to create
244  * a ring and then mmaps it to userspace memory. If it is a response
245  * ring and there is no reading thread running for the device
246  * the function creates one.
247  */
248 CpaStatus icp_adf_transCreateHandle(icp_accel_dev_t *accel_dev,
249                                     icp_transport_type trans_type,
250                                     const char *section,
251                                     const Cpa32U accel_nr,
252                                     const Cpa32U bank_nr,
253                                     const char *service_name,
254                                     const icp_adf_ringInfoService_t info,
255                                     icp_trans_callback callback,
256                                     icp_resp_deliv_method resp,
257                                     const Cpa32U num_msgs,
258                                     const Cpa32U msg_size,
259                                     icp_comms_trans_handle *trans_handle)
260 {    
261     CpaStatus status = CPA_STATUS_SUCCESS;
262     adf_dev_ring_handle_t *pRingHandle = NULL;
263     Cpa32U ring_number = 0;
264     Cpa32U in_flight_index = 0;
265     size_t len = 0;
266 
267     ICP_CHECK_FOR_NULL_PARAM(accel_dev);
268     ICP_CHECK_FOR_NULL_PARAM(trans_handle);
269 
270     adf_dev_bank_handle_t *banks = accel_dev->banks;
271     adf_dev_bank_handle_t *bank = &banks[bank_nr];
272     int nodeid = accel_dev->numa_node;
273     int ring_rnum = 0;
274     char val[ADF_CFG_MAX_VAL_LEN_IN_BYTES];
275 
276     /* here init the bank: get a free bundle from UIO and mmap it
277      * It's not suitable to put it into device init stage,
278      * for at that time, we don't know which device the user will be use */
279     if (NULL == bank->bundle)
280     {
281         ICP_MUTEX_LOCK(bank->user_bank_lock);
282         if (0 > init_bank_from_accel(accel_dev, bank))
283         {
284             ICP_MUTEX_UNLOCK(bank->user_bank_lock);
285             return CPA_STATUS_FAIL;
286         }
287         ICP_MUTEX_UNLOCK(bank->user_bank_lock);
288     }
289 
290     if (CPA_STATUS_SUCCESS ==
291         icp_adf_cfgGetParamValue(accel_dev, section, service_name, val))
292     {
293         ring_rnum = strtoul(val, NULL, 10);
294         if ((ring_rnum < 0) || (ring_rnum >= accel_dev->maxNumRingsPerBank))
295         {
296             ADF_ERROR("Invalid ring num\n");
297             adf_free_bundle(bank);
298             return CPA_STATUS_FAIL;
299         }
300     }
301     else
302     {
303         adf_free_bundle(bank);
304         return CPA_STATUS_FAIL;
305     }
306 
307     /* Reserve the ring in the kernel driver */
308     if (CPA_STATUS_SUCCESS !=
309         icp_adf_reserve_ring(accel_dev->accelId, bank_nr, ring_rnum))
310     {
311         adf_free_bundle(bank);
312         return CPA_STATUS_FAIL;
313     }
314 
315     /* allocate and setup ring handle structure */
316     pRingHandle = ICP_MALLOC_GEN(sizeof(adf_dev_ring_handle_t));
317     if (NULL == pRingHandle)
318     {
319         ADF_ERROR("unable to allocate pRingHandle buffer\n");
320         icp_adf_release_ring(accel_dev->accelId, bank_nr, ring_rnum);
321         adf_free_bundle(bank);
322 
323         return CPA_STATUS_FAIL;
324     }
325     ICP_MEMSET(pRingHandle, 0, sizeof(adf_dev_ring_handle_t));
326     pRingHandle->accel_dev = accel_dev;
327     pRingHandle->trans_type = trans_type;
328     len = ICP_STRNLEN(service_name, ICP_MAX_STR_LEN) + 1;
329     pRingHandle->service_name = ICP_MALLOC_GEN(len);
330     if (NULL == pRingHandle->service_name)
331     {
332         ADF_ERROR("unable to allocate service buffer\n");
333         ICP_FREE(pRingHandle);
334         icp_adf_release_ring(accel_dev->accelId, bank_nr, ring_rnum);
335         adf_free_bundle(bank);
336 
337         return CPA_STATUS_FAIL;
338     }
339     memcpy(pRingHandle->service_name, service_name, len);
340     pRingHandle->service_name_len = len;
341     pRingHandle->callback = callback;
342     pRingHandle->accel_num = accel_nr;
343     pRingHandle->bank_num = bank_nr;
344     len = ICP_STRNLEN(section, ICP_MAX_STR_LEN) + 1;
345     pRingHandle->section_name = ICP_MALLOC_GEN(len);
346     if (NULL == pRingHandle->section_name)
347     {
348         ADF_ERROR("unable to allocate section name buffer\n");
349         ICP_FREE(pRingHandle->service_name);
350         ICP_FREE(pRingHandle);
351         icp_adf_release_ring(accel_dev->accelId, bank_nr, ring_rnum);
352         adf_free_bundle(bank);
353 
354         return CPA_STATUS_FAIL;
355     }
356     memcpy(pRingHandle->section_name, section, len);
357     pRingHandle->section_name_len = len;
358     pRingHandle->resp = resp;
359     pRingHandle->info = info;
360     if (ICP_RESP_TYPE_POLL == resp)
361     {
362         /* Set the polling mask for this ring handle. */
363         pRingHandle->pollingMask = 1 << ring_rnum;
364     }
365     else if (ICP_RESP_TYPE_IRQ == resp)
366     {
367         /* epoll rings are also polled, so we neeed to set both
368          * their polling and interrupt mask
369          */
370         pRingHandle->pollingMask = 1 << ring_rnum;
371         pRingHandle->interrupt_user_mask = 1 << ring_rnum;
372     }
373     else if (ICP_RESP_TYPE_NONE != resp)
374     {
375         ADF_ERROR("Not implemented yet\n");
376         ICP_FREE(pRingHandle->service_name);
377         ICP_FREE(pRingHandle->section_name);
378         ICP_FREE(pRingHandle);
379         icp_adf_release_ring(accel_dev->accelId, bank_nr, ring_rnum);
380         adf_free_bundle(bank);
381         return CPA_STATUS_FAIL;
382     }
383 
384     /* To save size we are going to reuse the ring space var
385      * to pass down the ring num_msgs. space is in bytes
386      * and is only used later in the msg put and get logic.
387      * num_msgs is used only to allocate appropriate
388      * memory for the ring and is not subsequently stored
389      */
390     pRingHandle->space = num_msgs;
391     pRingHandle->message_size = msg_size;
392     if (CPA_STATUS_SUCCESS != adf_init_ring(pRingHandle,
393                                             bank,
394                                             ring_rnum,
395                                             bank->csr_addr,
396                                             num_msgs,
397                                             msg_size,
398                                             nodeid))
399     {
400         ADF_ERROR("adf_init_ring failed\n");
401         ICP_FREE(pRingHandle->section_name);
402         ICP_FREE(pRingHandle->service_name);
403         ICP_FREE(pRingHandle);
404         icp_adf_release_ring(accel_dev->accelId, bank_nr, ring_rnum);
405         adf_free_bundle(bank);
406         return CPA_STATUS_FAIL;
407     }
408 
409     adf_dev_bank_handle_get(bank);
410 
411     pRingHandle->accel_dev = accel_dev;
412     *trans_handle = (icp_comms_trans_handle *)pRingHandle;
413     status = icp_adf_transGetRingNum(*trans_handle, &ring_number);
414     if (CPA_STATUS_SUCCESS != status)
415     {
416         ADF_ERROR("icp_adf_transGetRingNum failed\n");
417         icp_adf_transReleaseHandle(*trans_handle);
418         *trans_handle = NULL;
419         return CPA_STATUS_FAIL;
420     }
421 
422     /* callback has been overwritten in kernelspace
423      * so have to set it to the userspace callback again */
424     pRingHandle->callback = callback;
425     (bank->rings)[ring_rnum] = pRingHandle;
426     banks[pRingHandle->bank_num].interrupt_mask |=
427         pRingHandle->interrupt_user_mask;
428     banks[pRingHandle->bank_num].pollingMask |= pRingHandle->pollingMask;
429 
430     /* Configure interrupts in the hardware only for epoll mode */
431     if (ICP_RESP_TYPE_IRQ == resp)
432     {
433         uint32_t *csr_base_addr = pRingHandle->csr_addr;
434         WRITE_CSR_INT_COL_EN(pRingHandle->bank_offset,
435                              banks[pRingHandle->bank_num].interrupt_mask);
436     }
437 
438     /* request and response ring will share the same index */
439     if (pRingHandle->ring_num < accel_dev->maxNumRingsPerBank / 2)
440     {
441         in_flight_index =
442             ((accel_dev->maxNumRingsPerBank * pRingHandle->bank_num) >> 1) +
443             pRingHandle->ring_num;
444     }
445     else
446     {
447         in_flight_index =
448             ((accel_dev->maxNumRingsPerBank * pRingHandle->bank_num) >> 1) +
449             (pRingHandle->ring_num - accel_dev->maxNumRingsPerBank / 2);
450     }
451     /* Initialise the pRingHandle inflight */
452     pRingHandle->in_flight =
453         ringInflights[accel_dev->accelId] + in_flight_index;
454     *pRingHandle->in_flight = 0;
455     /* Initialise the pRingHandle atomic flag. */
456     osalAtomicSet(1, (OsalAtomic *)&(pRingHandle->pollingInProgress));
457     pRingHandle->user_lock = ICP_MALLOC_GEN(sizeof(ICP_MUTEX));
458     if (!pRingHandle->user_lock)
459     {
460         ADF_ERROR("Could not alloc memory for ring lock\n");
461         icp_adf_transReleaseHandle(*trans_handle);
462         *trans_handle = NULL;
463         return CPA_STATUS_FAIL;
464     }
465     ICP_MUTEX_INIT(pRingHandle->user_lock);
466     return CPA_STATUS_SUCCESS;
467 }

```

282: init\_bank\_from\_accel\(\)申请bank-&gt;rings数组:

```c
107 CpaStatus init_bank_from_accel(icp_accel_dev_t *accel_dev,
108                                adf_dev_bank_handle_t *bank)
109 {
110     uint32_t size = 0;
111     struct adf_uio_user_bundle *bundle = NULL;
112
113     bundle = uio_get_bundle_from_accelid(accel_dev->accelId, bank->bank_number);
114     if (NULL == bundle)
115         return CPA_STATUS_FAIL;
116
117     bank->csr_addr = (uint32_t *)bundle->ptr;
118     bank->bundle = bundle;
119
120     /*  allocate ring handles for this bank  */
121     size = sizeof(adf_dev_ring_handle_t *) * (accel_dev->maxNumRingsPerBank);
122     bank->rings = ICP_MALLOC_GEN(size);
123     if (NULL == bank->rings)
124     {
125         uio_free_bundle(bundle);
126         return CPA_STATUS_FAIL;
127     }
128
129     ICP_MEMSET(bank->rings, 0, size);
130
131     return CPA_STATUS_SUCCESS;
132 }
```

315-398: 申请ring并初始化;

```c
315 int32_t adf_init_ring(adf_dev_ring_handle_t *ring,
316                       adf_dev_bank_handle_t *bank,
317                       uint32_t ring_num,
318                       uint32_t *csr_base_addr,
319                       uint32_t num_msgs,
320                       uint32_t msg_size,
321                       int nodeid)
322 {
323     uint32_t modulo = 0;
324     uint32_t ring_size_cfg = validateRingSize(num_msgs, msg_size, &modulo);
325     uint32_t ring_size_bytes = ICP_ET_SIZE_TO_BYTES(ring_size_cfg);
326     uint64_t ring_base_cfg, ring_config;
327     uint8_t nearly_full_wm = ICP_RING_NEAR_WATERMARK_512;
328     uint8_t nearly_empty_wm = ICP_RING_NEAR_WATERMARK_0;
329     uint32_t max_space = ring_size_bytes;
330
331     /* Exclusive access to one ring */
332     if (adf_reserve_ring(bank, ring_num))
333     {
334         ADF_ERROR(
335             "Ring [%u:%u] existed already\n", bank->bank_number, ring_num);
336         return -EBUSY;
337     }
338
339     ring->head = 0;
340     ring->tail = 0;
341     ring->send_seq = 0;
342     ring->bank_data = bank;
343     /* Now the bank offset is 0 because we get the band's offset */
344     ring->bank_offset = 0;
345     ring->ring_num = ring_num;
346     ring->csr_addr = csr_base_addr;
347     ring->message_size = msg_size;
348     ring->modulo = modulo;
349     ring->ring_size = ring_size_bytes;
350     ring->ring_virt_addr =
351         qaeMemAllocNUMA(ring_size_bytes, nodeid, ring_size_bytes);
352     ring->ring_phys_base_addr = qaeVirtToPhysNUMA(ring->ring_virt_addr);
353     if ((NULL == ring->ring_virt_addr) || (0 == ring->ring_phys_base_addr))
354     {
355         ADF_ERROR("unable to get ringbuf(v:%p,p:%p) for rings in bank(%u)\n",
356                   ring->ring_virt_addr,
357                   ring->ring_phys_base_addr,
358                   ring->ring_num);
359         adf_unreserve_ring(bank, ring_num);
360         if (ring->ring_phys_base_addr)
361             qaeMemFreeNUMA(&ring->ring_virt_addr);
362         return -ENOMEM;
363     }
364     ICP_MEMSET(ring->ring_virt_addr, EMPTY_RING_SIG_BYTE, ring_size_bytes);
365
366     ring->min_resps_per_head_write =
367         ((max_space / msg_size) >> 1 > MIN_RESPONSES_PER_HEAD_WRITE)
368             ? MIN_RESPONSES_PER_HEAD_WRITE
369             : (max_space / msg_size) >> 1;
370     ring->max_requests_inflight = num_msgs - 1;
371
372     ring_base_cfg =
373         BUILD_RING_BASE_ADDR(ring->ring_phys_base_addr, ring_size_cfg);
374     WRITE_CSR_RING_BASE(ring->bank_offset, ring->ring_num, ring_base_cfg);
375
376     if (bank->tx_rings_mask & (1 << ring_num))
377     {
378         ring_config = BUILD_RING_CONFIG(ring_size_cfg);
379     }
380     else
381     {
382         ring_config = BUILD_RESP_RING_CONFIG(
383             ring_size_cfg, nearly_full_wm, nearly_empty_wm);
384     }
385     WRITE_CSR_RING_CONFIG(ring->bank_offset, ring->ring_num, ring_config);
386
387     icp_adf_enable_ring(
388         ring->accel_dev->accelId, ring->bank_num, ring->ring_num);
389
390     return 0;
391 }
```

### 3.5.3.9 Service Start

```c
355 /*
356  * adf_user_subsystemStart
357  * This function sends a start event to the registered subcomponents
358  */
359 CpaStatus adf_user_subsystemStart(icp_accel_dev_t *accel_dev)
360 {
361     CpaStatus status = CPA_STATUS_FAIL;
362     subservice_registation_handle_t *subsystem_hdl = pSubsystemTableHead;
363     ICP_CHECK_FOR_NULL_PARAM(accel_dev);
364
365     while (NULL != subsystem_hdl)
366     {
367         ADF_DEBUG("Sending event %d to %s\n",
368                   ADF_EVENT_START,
369                   subsystem_hdl->subsystem_name);
370
371         status = subsystem_hdl->subserviceEventHandler(
372             accel_dev, ADF_EVENT_START, NULL);
373
374         if (CPA_STATUS_SUCCESS == status)
375         {
376             SET_STATUS_BIT(subsystem_hdl->subsystemStatus[accel_dev->accelId]
377                                .subsystemStartBit,
378                            0);
379         }
380         else
381         {
382             ADF_ERROR("Failed to start Subservice %s\n",
383                       subsystem_hdl->subsystem_name);
384             SET_STATUS_BIT(subsystem_hdl->subsystemStatus[accel_dev->accelId]
385                                .subsystemFailedBit,
386                            0);
387             return status;
388         }
389         subsystem_hdl = subsystem_hdl->pNext;
390     }
391     return status;
392 }
```

371-372: subsystem\_hdl-&gt;subserviceEventHandler指向的函数是SalCtrl\_ServiceEventHandler\(\), 此函数在event == ADF\_EVENT\_START时会调用SalCtrl\_ServiceEventStart\(\):

```c
1290 STATIC CpaStatus SalCtrl_ServiceEventStart(icp_accel_dev_t *device,
1291                                            Cpa32U enabled_services)
1292 {
1293     CpaStatus status = CPA_STATUS_SUCCESS;
1294     sal_t *service_container = device->pSalHandle;
1295
1296     if (service_container == NULL)
1297     {
1298         LAC_LOG_ERROR("Private data is NULL");
1299         return CPA_STATUS_FATAL;
1300     }
1301
1302     if (SalCtrl_IsServiceEnabled(enabled_services,
1303                                  SAL_SERVICE_TYPE_CRYPTO_ASYM))
1304     {
1305         status = SalCtrl_ServiceStart(device, service_container->asym_services);
1306         if (CPA_STATUS_SUCCESS != status)
1307         {
1308             goto err_start;
1309         }
1310     }
1311
1312     if (SalCtrl_IsServiceEnabled(enabled_services, SAL_SERVICE_TYPE_CRYPTO_SYM))
1313     {
1314         status = SalCtrl_ServiceStart(device, service_container->sym_services);
1315         if (CPA_STATUS_SUCCESS != status)
1316         {
1317             goto err_start;
1318         }
1319     }
1320
1321     if (SalCtrl_IsServiceEnabled(enabled_services, SAL_SERVICE_TYPE_CRYPTO))
1322     {
1323         status =
1324             SalCtrl_ServiceStart(device, service_container->crypto_services);
1325         if (CPA_STATUS_SUCCESS != status)
1326         {
1327             goto err_start;
1328         }
1329     }
1330
1331     if (SalCtrl_IsServiceEnabled(enabled_services,
1332                                  SAL_SERVICE_TYPE_COMPRESSION))
1333     {
1334         status = SalCtrl_ServiceStart(device,
1335                                       service_container->compression_services);
1336         if (CPA_STATUS_SUCCESS != status)
1337         {
1338             goto err_start;
1339         }
1340     }
1341
1342     return status;
1343 err_start:
1344     SalCtrl_ServiceEventStop(device, enabled_services);
1345     return status;
1346 }

```

```c
 675 STATIC CpaStatus SalCtrl_ServiceStart(icp_accel_dev_t *device,
 676                                       sal_list_t *services)
 677 {
 678     CpaStatus status = CPA_STATUS_SUCCESS;
 679
 680     /* Call Start function for each service instance */
 681     SAL_FOR_EACH(services, sal_service_t, device, start, status);
 682     if (CPA_STATUS_SUCCESS != status)
 683     {
 684         LAC_LOG_ERROR("Failed to start all instances");
 685         /* stop all instances started before error */
 686         SAL_FOR_EACH_STATE(
 687             services, sal_service_t, device, stop, SAL_SERVICE_STATE_RUNNING);
 688         return status;
 689     }
 690
 691     if (icp_adf_is_dev_in_reset(device))
 692     {
 693         sal_list_t *curr_element = services;
 694         sal_service_t *service = NULL;
 695         while (NULL != curr_element)
 696         {
 697             service = (sal_service_t *)SalList_getObject(curr_element);
 698             if (service->notification_cb)
 699             {
 700                 service->notification_cb(
 701                     service, service->cb_tag, CPA_INSTANCE_EVENT_RESTARTED);
 702             }
 703             curr_element = SalList_next(curr_element);
 704         }
 705     }
 706
 707     return status;
 708 }
```

SAL\_FOR\_EACH宏函数会调用的sal\_service\_t-&gt;start函数由SalCtrl\_ServiceCreate\(\)函数的代码可知是SalCtrl\_CryptoStart\(\):

```c
1959 CpaStatus SalCtrl_CryptoStart(icp_accel_dev_t *device, sal_service_t *service)
1960 {
1961     sal_crypto_service_t *pCryptoService = (sal_crypto_service_t *)service;
1962     CpaStatus status = CPA_STATUS_SUCCESS;
1963
1964     if (pCryptoService->generic_service_info.state !=
1965         SAL_SERVICE_STATE_INITIALIZED)
1966     {
1967         LAC_LOG_ERROR("Not in the correct state to call start\n");
1968         return CPA_STATUS_FAIL;
1969     }
1970
1971     pCryptoService->generic_service_info.state = SAL_SERVICE_STATE_RUNNING;
1972     return status;
1973 }
```

看来service start的关键操作是将service的state设置为SAL\_SERVICE\_STATE\_RUNNING.

## 3.5.4 cpaCyGetNumInstances

获取instance的数量:

```c
2314 CpaStatus cpaCyGetNumInstances(Cpa16U *pNumInstances)                                                                                                                                                                                    
2315 {
2316     CpaStatus status = CPA_STATUS_SUCCESS;
2317     icp_accel_dev_t **pAdfInsts = NULL;
2318     icp_accel_dev_t *dev_addr = NULL;
2319     sal_t *base_addr = NULL;
2320     sal_list_t *list_temp = NULL;  
2321     Cpa16U num_accel_dev = 0;
2322     Cpa16U num_inst = 0;
2323     Cpa16U i = 0;
2324 
2325     LAC_CHECK_NULL_PARAM(pNumInstances);                                                                                                                                                                                                 
2326 
2327     /* Get the number of accel_dev in the system */
2328     status = icp_amgr_getNumInstances(&num_accel_dev);
2329     LAC_CHECK_STATUS(status);
2330 
2331     /* Allocate memory to store addr of accel_devs */
2332     pAdfInsts = osalMemAlloc(num_accel_dev * sizeof(icp_accel_dev_t *));                                                                                                                                                                 
2333     if (NULL == pAdfInsts)
2334     {
2335         LAC_LOG_ERROR("Failed to allocate dev instance memory");
2336         return CPA_STATUS_RESOURCE;
2337     }
2338     num_accel_dev = 0;   
2339     /* Get ADF to return all accel_devs that support either
2340      * symmetric or asymmetric crypto */
2341     status = icp_amgr_getAllAccelDevByCapabilities(
2342         (ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC |
2343          ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC),                                                                                                                                                                                       
2344         pAdfInsts,       
2345         &num_accel_dev); 
2346     if (CPA_STATUS_SUCCESS != status)                                                                                                                                                                                                    
2347     {
2348         LAC_LOG_ERROR("No support for crypto\n");
2349         *pNumInstances = 0;
2350         osalMemFree(pAdfInsts);        
2351         return status;
2352     }
2353 
2354     for (i = 0; i < num_accel_dev; i++)                                                                                                                                                                                                  
2355     {
2356         dev_addr = (icp_accel_dev_t *)pAdfInsts[i];
2357         if (NULL == dev_addr || NULL == dev_addr->pSalHandle)                                                                                                                                                                            
2358         {
2359             continue;
2360         }
2361 
2362         base_addr = dev_addr->pSalHandle;
2363         list_temp = base_addr->crypto_services;
2364         while (NULL != list_temp)
2365         {
2366             num_inst++;
2367             list_temp = SalList_next(list_temp);
2368         }
2369         list_temp = base_addr->asym_services;
2370         while (NULL != list_temp)
2371         {
2372             num_inst++;
2373             list_temp = SalList_next(list_temp);
2374         }
2375         list_temp = base_addr->sym_services;
2376         while (NULL != list_temp)
2377         {
2378             num_inst++;
2379             list_temp = SalList_next(list_temp);
2380         }
2381     }
2382     *pNumInstances = num_inst;
2383     osalMemFree(pAdfInsts);
2384 
2385 #ifdef ICP_TRACE
2386     if (NULL != pNumInstances)
2387     {
2388         LAC_LOG2("Called with params (0x%lx[%d])\n",
2389                  (LAC_ARCH_UINT)pNumInstances,
2390                  *pNumInstances);
2391     }
2392     else
2393     {
2394         LAC_LOG1("Called with params (0x%lx)\n", (LAC_ARCH_UINT)pNumInstances);
2395     }
2396 #endif
2397 
2398     return status;
2399 }
```

2341-2345: 调用icp\_amgr\_getAllAccelDevByCapabilities\(\)获取所有device信息;

```c
846 /*
847  * icp_amgr_getAllAccelDevByCapabilities
848  * Returns table of accel devices that are started and implement
849  * the capabilities specified in capabilitiesMask.
850  */
851 CpaStatus icp_amgr_getAllAccelDevByCapabilities(Cpa32U capabilitiesMask,
852                                                 icp_accel_dev_t **pAccel_devs,
853                                                 Cpa16U *pNumInstances)
854 {
855     icp_accel_dev_t **ptr = accel_tbl;
856     ICP_CHECK_FOR_NULL_PARAM(pAccel_devs);
857     ICP_CHECK_FOR_NULL_PARAM(pNumInstances);
858     Cpa16U i = 0;
859     
860     *pNumInstances = 0;
861     for (i = 0; i < ADF_MAX_DEVICES; i++, ptr++)
862     {
863         if (NULL != *ptr)
864         {
865             if ((*ptr)->accelCapabilitiesMask & capabilitiesMask)
866             {
867                 if ((*ptr)->adfSubsystemStatus)
868                 {
869                     pAccel_devs[(*pNumInstances)++] = (icp_accel_dev_t *)*ptr;
870                 }
871             }
872         }
873     }
874     return CPA_STATUS_SUCCESS;
875 }

```

2354-2356: 遍历所有device; 

2363-2368: 遍历crypto\_services list得到instance的数量;

2369-2374: 遍历asym\_services list累加instance的数量;

2375-2380: 遍历sym\_services list累加instance的数量;

上述instance的初始化详见[Service Init](https://app.gitbook.com/@remyknight/s/workspace/~/drafts/-MigxyjadB-9i_dm5bnx/part5-ssl-accelerate-intel-qat/chapter-3-quickassist-driver/3.5-engine-init#3-5-3-8-service-init).

2382: 返回结果.

## 3.5.5 cpaCyGetInstances

这个函数需要得到所有instance的handle:

```c
2405 CpaStatus cpaCyGetInstances(Cpa16U numInstances,
2406                             CpaInstanceHandle *pCyInstances)
2407 {
2408     CpaStatus status = CPA_STATUS_SUCCESS;
2409     icp_accel_dev_t **pAdfInsts = NULL;
2410     icp_accel_dev_t *dev_addr = NULL;
2411     sal_t *base_addr = NULL;
2412     sal_list_t *list_temp = NULL;
2413     Cpa16U num_accel_dev = 0;
2414     Cpa16U num_allocated_instances = 0;
2415     Cpa16U index = 0;
2416     Cpa16U i = 0;
2417 
2418 #ifdef ICP_TRACE
2419     LAC_LOG2("Called with params (%d, 0x%lx)\n",
2420              numInstances,
2421              (LAC_ARCH_UINT)pCyInstances);
2422 #endif
2423 
2424     LAC_CHECK_NULL_PARAM(pCyInstances);
2425     if (0 == numInstances)
2426     {
2427         LAC_INVALID_PARAM_LOG("NumInstances is 0");
2428         return CPA_STATUS_INVALID_PARAM;
2429     }
2430 
2431     /* Get the number of crypto instances */
2432     status = cpaCyGetNumInstances(&num_allocated_instances);
2433     if (CPA_STATUS_SUCCESS != status)
2434     {
2435         return status;
2436     }
2437 
2438     if (numInstances > num_allocated_instances)
2439     {
2440         LAC_LOG_ERROR1("Only %d crypto instances available",
2441                        num_allocated_instances);
2442         return CPA_STATUS_RESOURCE;
2443     }
2444 
2445     /* Get the number of accel devices in the system */
2446     status = icp_amgr_getNumInstances(&num_accel_dev);
2447     LAC_CHECK_STATUS(status);
2448 
2449     /* Allocate memory to store addr of accel_devs */
2450     pAdfInsts = osalMemAlloc(num_accel_dev * sizeof(icp_accel_dev_t *));
2451     if (NULL == pAdfInsts)
2452     {
2453         LAC_LOG_ERROR("Failed to allocate dev instance memory");
2454         return CPA_STATUS_RESOURCE;
2455     }
2456 
2457     num_accel_dev = 0;
2458     /* Get ADF to return all accel_devs that support either
2459      * symmetric or asymmetric crypto */
2460     status = icp_amgr_getAllAccelDevByCapabilities(
2461         (ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC |
2462          ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC),
2463         pAdfInsts,
2464         &num_accel_dev);
2465     if (CPA_STATUS_SUCCESS != status)
2466     {
2467         LAC_LOG_ERROR("No support for crypto\n");
2468         osalMemFree(pAdfInsts);
2469         return status;
2470     }
2471 
2472     for (i = 0; i < num_accel_dev; i++)
2473     {
2474         dev_addr = (icp_accel_dev_t *)pAdfInsts[i];
2475         /* Note dev_addr cannot be NULL here as numInstances = 0
2476          * is not valid and if dev_addr = NULL then index = 0 (which
2477          * is less than numInstances and status is set to _RESOURCE
2478          * above
2479          */
2480         base_addr = dev_addr->pSalHandle;
2481         if (NULL == base_addr)
2482         {
2483             continue;
2484         }
2485         list_temp = base_addr->crypto_services;
2486         while (NULL != list_temp)
2487         {
2488             if (index > (numInstances - 1))
2489             {
2490                 break;
2491             }
2492             pCyInstances[index] = SalList_getObject(list_temp);
2493             list_temp = SalList_next(list_temp);
2494             index++;
2495         }
2496         list_temp = base_addr->asym_services;
2497         while (NULL != list_temp)
2498         {
2499             if (index > (numInstances - 1))
2500             {
2501                 break;
2502             }
2503             pCyInstances[index] = SalList_getObject(list_temp);
2504             list_temp = SalList_next(list_temp);
2505             index++;
2506         }
2507         list_temp = base_addr->sym_services;
2508         while (NULL != list_temp)
2509         {
2510             if (index > (numInstances - 1))
2511             {
2512                 break;
2513             }
2514             pCyInstances[index] = SalList_getObject(list_temp);
2515             list_temp = SalList_next(list_temp);
2516             index++;
2517         }
2518     }
2519     osalMemFree(pAdfInsts);
2520 
2521     return status;
2522 }
```

1432: 得到instance的数量;

2446-2464: 获取所有device的信息;

2472-2474: 遍历device;

2080-2518: 将crypto, asym, sym service list中所有的instance指针copy到pCyInstances\[\]中.

上述instance的初始化详见[Service Init](https://app.gitbook.com/@remyknight/s/workspace/~/drafts/-MigxyjadB-9i_dm5bnx/part5-ssl-accelerate-intel-qat/chapter-3-quickassist-driver/3.5-engine-init#3-5-3-8-service-init).

## 3.5.6 icp\_sal\_CyGetFileDescriptor

```c
3277 CpaStatus icp_sal_CyGetFileDescriptor(CpaInstanceHandle instanceHandle, int *fd)
3278 {
3279     sal_crypto_service_t *crypto_handle = NULL;
3280     sal_service_t *gen_handle = NULL;
3281     CpaStatus status = CPA_STATUS_SUCCESS;
3282
3283     crypto_handle = (sal_crypto_service_t *)instanceHandle;
3284
3285     /* Make sure that we zero file descriptor
3286      * in case of error or unsupported. */
3287     LAC_CHECK_NULL_PARAM(fd);
3288     *fd = 0;
3289
3290     LAC_CHECK_NULL_PARAM(crypto_handle);
3291     SAL_RUNNING_CHECK(crypto_handle);
3292     if (SAL_RESP_EPOLL_CFG_FILE != crypto_handle->isPolled)
3293     {
3294         return CPA_STATUS_UNSUPPORTED;
3295     }
3296
3297     gen_handle = &(crypto_handle->generic_service_info);
3298
3299     switch (gen_handle->type)
3300     {
3301         case SAL_SERVICE_TYPE_CRYPTO:
3302         {
3303             status = SalCtrl_CyGetFileDescriptor(crypto_handle, fd);
3304             break;
3305         }
3306         case SAL_SERVICE_TYPE_CRYPTO_ASYM:
3307         {
3308             status = SalCtrl_AsymGetFileDescriptor(crypto_handle, fd);
3309             break;
3310         }
3311         case SAL_SERVICE_TYPE_CRYPTO_SYM:
3312         {
3313             status = SalCtrl_SymGetFileDescriptor(crypto_handle, fd);
3314             break;
3315         }
3316         default:
3317             LAC_LOG_ERROR("The instance handle is the wrong type");
3318             return CPA_STATUS_FAIL;
3319     }
3320
3321     return status;
3322 }
```

```c
 214 STATIC
 215 CpaStatus SalCtrl_CyGetFileDescriptor(sal_crypto_service_t *crypto_handle,
 216                                       int *fd)
 217 {
 218     CpaStatus ret_sym = CPA_STATUS_SUCCESS;
 219     CpaStatus ret_asym = CPA_STATUS_SUCCESS;
 220     int fd_sym = -1;
 221     int fd_asym = -1;
 222
 223     ret_sym = SalCtrl_SymGetFileDescriptor(crypto_handle, &fd_sym);
 224     ret_asym = SalCtrl_AsymGetFileDescriptor(crypto_handle, &fd_asym);
 225
 226     if (ret_sym != CPA_STATUS_SUCCESS || ret_asym != CPA_STATUS_SUCCESS)
 227     {
 228         LAC_LOG_ERROR("Error getting file descriptor for crypto instance");
 229         return CPA_STATUS_FAIL;
 230     }
 231
 232     /* They should always be the same. Otherwise, return error */
 233     if (fd_sym != fd_asym)
 234     {
 235         LAC_LOG_ERROR("Symmetric and asymmetric crypto cannot be used"
 236                       " within the same instance across different bundles");
 237         return CPA_STATUS_FAIL;
 238     }
 239
 240     *fd = fd_sym;
 241     return CPA_STATUS_SUCCESS;
 242 }
```

```c
 166 STATIC
 167 CpaStatus SalCtrl_AsymGetFileDescriptor(sal_crypto_service_t *crypto_handle,
 168                                         int *fd)
 169 {
 170     int ret = 0;
 171     int fd_asym = -1;
 172
 173     if (NULL == crypto_handle->trans_handle_asym_rx)
 174     {
 175         return CPA_STATUS_FAIL;
 176     }
 177     ret = icp_adf_transGetFdForHandle(crypto_handle->trans_handle_asym_rx,
 178                                       &fd_asym);
 179
 180     if (ret != CPA_STATUS_SUCCESS)
 181     {
 182         LAC_LOG_ERROR("Error getting file descriptor for asym instance");
 183         return CPA_STATUS_FAIL;
 184     }
 185
 186     *fd = fd_asym;
 187     return CPA_STATUS_SUCCESS;
 188 }
 189
 190 STATIC
 191 CpaStatus SalCtrl_SymGetFileDescriptor(sal_crypto_service_t *crypto_handle,
 192                                        int *fd)
 193 {
 194     int ret = 0;
 195     int fd_sym = -1;
 196
 197     if (NULL == crypto_handle->trans_handle_sym_rx)
 198     {
 199         return CPA_STATUS_FAIL;
 200     }
 201     ret = icp_adf_transGetFdForHandle(crypto_handle->trans_handle_sym_rx,
 202                                       &fd_sym);
 203
 204     if (ret != CPA_STATUS_SUCCESS)
 205     {
 206         LAC_LOG_ERROR("Error getting file descriptor for sym instance");
 207         return CPA_STATUS_FAIL;
 208     }
 209
 210     *fd = fd_sym;
 211     return CPA_STATUS_SUCCESS;
 212 }
```

```c
811 /*
812  * This will set the fd of the UIO device this instance
813  * handler is using. If more than one transaction handler
814  * are ever present, this will need to be refactored to
815  * return the appropiate fd of the appropiate bank
816  */
817 CpaStatus icp_adf_transGetFdForHandle(icp_comms_trans_handle trans_hnd, int *fd)
818 {
819     int local_fd = -1;
820     adf_dev_ring_handle_t *ring_handle = (adf_dev_ring_handle_t *)trans_hnd;
821     struct adf_uio_user_bundle *bundle =
822         (struct adf_uio_user_bundle *)ring_handle->bank_data->bundle;
823     local_fd = bundle->fd;
824
825     if (local_fd >= 0)
826     {
827         *fd = local_fd;
828         return CPA_STATUS_SUCCESS;
829     }
830     else
831     {
832         return CPA_STATUS_FAIL;
833     }
834 }
```

823: 将bundle-&gt;fd输出成为handle的fd.

这个bundle-&gt;fd是怎么来的呢？3.5.3.8 Service Init节中，icp\_adf\_transCreateHandle\(\)中调用的init\_bank\_from\_accel\(\)会调用uio\_get\_bundle\_from\_accelid\(\)生成bundle.

```c
144 struct adf_uio_user_bundle *uio_get_bundle_from_accelid(int accelid,
145                                                         int bundle_nr)
146 {
147     struct udev_device *dev;
148     struct adf_uio_user_bundle *bundle;
149
150     if (CPA_STATUS_SUCCESS != uio_udev_get_device_from_devid(accelid, &dev))
151         return NULL;
152
153     bundle = get_bundle_from_dev_cached(dev, bundle_nr);
154
155     return bundle;
156 }
```

```c
 90 /**
 91  * This function is using 'udev_device_get_sysattr_value()' function.
 92  *
 93  * From man pages: The retrieved value is cached in the device.
 94  * Repeated calls will return the same value and not open the attribute again.
 95  *
 96  * More calls of 'get_free_bundle_from_dev_cached()' without enumerating
 97  * of the device via 'uio_udev_get_device_from_devid()' gives incorrect values
 98  * and is major issue for 'used' flag! (e.g. 'uio_ctrl/bundle_0/used').
 99  */
100 static inline struct adf_uio_user_bundle *get_bundle_from_dev_cached(
101     struct udev_device *dev,
102     int bundle_nr)
103 {
104     unsigned long attribute_value;
105     struct adf_uio_user_bundle *bundle = NULL;
106     char uio_dev_name[32];
107
108     if (uio_udev_read_str(dev,
109                           uio_dev_name,
110                           sizeof(uio_dev_name),
111                           UDEV_ATTRIBUTE_DEV_NAME,
112                           bundle_nr) != CPA_STATUS_SUCCESS)
113         return NULL;
114
115     bundle = ICP_MALLOC_GEN(sizeof(*bundle));
116     if (!bundle)
117     {
118         perror("failed to allocate bundle structure\n");
119         return NULL;
120     }
121     bundle->fd = open(uio_dev_name, O_RDWR);
122     if (bundle->fd < 0)
123     {
124         ADF_ERROR("failed to open uio dev %s\n", uio_dev_name);
125         ICP_FREE(bundle);
126         return NULL;
127     }
128     bundle->udev_dev = dev;
129     uio_udev_read_long(
130         dev, &attribute_value, UDEV_ATTRIBUTE_DEV_MINOR, bundle_nr);
131     bundle->device_minor = attribute_value;
132     ADF_DEBUG("Opened uio device %s\n", uio_dev_name);
133
134     bundle->ptr = uio_map_bundle_ptr(bundle);
135     if (NULL == bundle->ptr)
136     {
137         close(bundle->fd);
138         ICP_FREE(bundle);
139         return NULL;
140     }
141     return bundle;
142 }

```

121: bundle-&gt;fd就是打开的uio dev的fd.

